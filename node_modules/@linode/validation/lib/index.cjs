"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AttachVolumeSchema: () => AttachVolumeSchema,
  AutoscaleNodePoolSchema: () => AutoscaleNodePoolSchema,
  CUSTOM_PORTS_ERROR_MESSAGE: () => CUSTOM_PORTS_ERROR_MESSAGE,
  CertificateEntrySchema: () => CertificateEntrySchema,
  CloneVolumeSchema: () => CloneVolumeSchema,
  ConfigurationSchema: () => ConfigurationSchema,
  CreateBasicLoadbalancerSchema: () => CreateBasicLoadbalancerSchema,
  CreateBucketSchema: () => CreateBucketSchema,
  CreateCertificateSchema: () => CreateCertificateSchema,
  CreateConfigurationSchema: () => CreateConfigurationSchema,
  CreateFirewallDeviceSchema: () => CreateFirewallDeviceSchema,
  CreateFirewallSchema: () => CreateFirewallSchema,
  CreateLinodeConfigSchema: () => CreateLinodeConfigSchema,
  CreateLinodeDiskFromImageSchema: () => CreateLinodeDiskFromImageSchema,
  CreateLinodeDiskSchema: () => CreateLinodeDiskSchema,
  CreateLinodeSchema: () => CreateLinodeSchema,
  CreateLoadBalancerRuleSchema: () => CreateLoadBalancerRuleSchema,
  CreateLoadBalancerSchema: () => CreateLoadBalancerSchema,
  CreateRouteSchema: () => CreateRouteSchema,
  CreateServiceTargetSchema: () => CreateServiceTargetSchema,
  CreateSnapshotSchema: () => CreateSnapshotSchema,
  CreateTransferSchema: () => CreateTransferSchema,
  CreateUserSchema: () => CreateUserSchema,
  CreateVolumeSchema: () => CreateVolumeSchema,
  CreditCardSchema: () => CreditCardSchema,
  EndpointSchema: () => EndpointSchema,
  FirewallDeviceSchema: () => FirewallDeviceSchema,
  FirewallRuleSchema: () => FirewallRuleSchema,
  FirewallRuleTypeSchema: () => FirewallRuleTypeSchema,
  HTTPRuleSchema: () => HTTPRuleSchema,
  IPAllocationSchema: () => IPAllocationSchema,
  IP_ERROR_MESSAGE: () => IP_ERROR_MESSAGE,
  LinodeInterfaceSchema: () => LinodeInterfaceSchema,
  LinodeInterfacesSchema: () => LinodeInterfacesSchema,
  NodeBalancerSchema: () => NodeBalancerSchema,
  PaymentMethodSchema: () => PaymentMethodSchema,
  PaymentSchema: () => PaymentSchema,
  PromoCodeSchema: () => PromoCodeSchema,
  RebuildLinodeFromStackScriptSchema: () => RebuildLinodeFromStackScriptSchema,
  RebuildLinodeSchema: () => RebuildLinodeSchema,
  ResizeLinodeDiskSchema: () => ResizeLinodeDiskSchema,
  ResizeVolumeSchema: () => ResizeVolumeSchema,
  SecurityQuestionsSchema: () => SecurityQuestionsSchema,
  SendCodeToPhoneNumberSchema: () => SendCodeToPhoneNumberSchema,
  TCPRuleSchema: () => TCPRuleSchema,
  UpdateAccountSettingsSchema: () => UpdateAccountSettingsSchema,
  UpdateBucketAccessSchema: () => UpdateBucketAccessSchema,
  UpdateCertificateSchema: () => UpdateCertificateSchema,
  UpdateConfigInterfaceOrderSchema: () => UpdateConfigInterfaceOrderSchema,
  UpdateConfigInterfaceSchema: () => UpdateConfigInterfaceSchema,
  UpdateConfigurationSchema: () => UpdateConfigurationSchema,
  UpdateFirewallSchema: () => UpdateFirewallSchema,
  UpdateGrantSchema: () => UpdateGrantSchema,
  UpdateLinodeConfigSchema: () => UpdateLinodeConfigSchema,
  UpdateLinodeDiskSchema: () => UpdateLinodeDiskSchema,
  UpdateLinodePasswordSchema: () => UpdateLinodePasswordSchema,
  UpdateLinodeSchema: () => UpdateLinodeSchema,
  UpdateNodeBalancerConfigSchema: () => UpdateNodeBalancerConfigSchema,
  UpdateNodeBalancerSchema: () => UpdateNodeBalancerSchema,
  UpdateRouteSchema: () => UpdateRouteSchema,
  UpdateServiceTargetSchema: () => UpdateServiceTargetSchema,
  UpdateUserSchema: () => UpdateUserSchema,
  UpdateVolumeSchema: () => UpdateVolumeSchema,
  UploadCertificateSchema: () => UploadCertificateSchema,
  VerifyPhoneNumberCodeSchema: () => VerifyPhoneNumberCodeSchema,
  allocateIPSchema: () => allocateIPSchema,
  assignAddressesSchema: () => assignAddressesSchema,
  baseImageSchema: () => baseImageSchema,
  clusterLabelSchema: () => clusterLabelSchema,
  createContactSchema: () => createContactSchema,
  createCredentialSchema: () => createCredentialSchema,
  createDatabaseSchema: () => createDatabaseSchema,
  createDomainSchema: () => createDomainSchema,
  createImageSchema: () => createImageSchema,
  createKubeClusterSchema: () => createKubeClusterSchema,
  createNodeBalancerConfigSchema: () => createNodeBalancerConfigSchema,
  createOAuthClientSchema: () => createOAuthClientSchema,
  createObjectStorageKeysSchema: () => createObjectStorageKeysSchema,
  createPersonalAccessTokenSchema: () => createPersonalAccessTokenSchema,
  createPlacementGroupSchema: () => createPlacementGroupSchema,
  createRecordSchema: () => createRecordSchema,
  createReplySchema: () => createReplySchema,
  createSSHKeySchema: () => createSSHKeySchema,
  createServiceMonitorSchema: () => createServiceMonitorSchema,
  createSubnetSchema: () => createSubnetSchema,
  createSupportTicketSchema: () => createSupportTicketSchema,
  createVPCSchema: () => createVPCSchema,
  credentialLabel: () => credentialLabel,
  credentialPassword: () => credentialPassword,
  credentialUsername: () => credentialUsername,
  determineIPType: () => determineIPType,
  enableTwoFactorSchema: () => enableTwoFactorSchema,
  importZoneSchema: () => importZoneSchema,
  ipAddress: () => ipAddress,
  isCustomPortsValid: () => isCustomPortsValid,
  longviewClientCreate: () => longviewClientCreate,
  modifySubnetSchema: () => modifySubnetSchema,
  nodeBalancerConfigNodeSchema: () => nodeBalancerConfigNodeSchema,
  nodePoolSchema: () => nodePoolSchema,
  shareAddressesSchema: () => shareAddressesSchema,
  sshSettingSchema: () => sshSettingSchema,
  stackScriptSchema: () => stackScriptSchema,
  updateAccountSchema: () => updateAccountSchema,
  updateCredentialSchema: () => updateCredentialSchema,
  updateDatabaseSchema: () => updateDatabaseSchema,
  updateDomainSchema: () => updateDomainSchema,
  updateIPSchema: () => updateIPSchema,
  updateImageSchema: () => updateImageSchema,
  updateManagedLinodeSchema: () => updateManagedLinodeSchema,
  updateOAuthClientSchema: () => updateOAuthClientSchema,
  updateObjectStorageKeysSchema: () => updateObjectStorageKeysSchema,
  updatePasswordSchema: () => updatePasswordSchema,
  updatePlacementGroupSchema: () => updatePlacementGroupSchema,
  updateProfileSchema: () => updateProfileSchema,
  updateRecordSchema: () => updateRecordSchema,
  updateSSHKeySchema: () => updateSSHKeySchema,
  updateStackScriptSchema: () => updateStackScriptSchema,
  updateVPCSchema: () => updateVPCSchema,
  uploadImageSchema: () => uploadImageSchema,
  validateIP: () => validateIP,
  vpcsValidateIP: () => vpcsValidateIP
});
module.exports = __toCommonJS(src_exports);

// src/account.schema.ts
var import_yup = require("yup");
var updateAccountSchema = (0, import_yup.object)({
  email: (0, import_yup.string)().max(128, "Email must be 128 characters or less."),
  address_1: (0, import_yup.string)().max(64, "Address must be 64 characters or less."),
  city: (0, import_yup.string)().max(24, "City must be 24 characters or less."),
  company: (0, import_yup.string)().max(128, "Company must be 128 characters or less."),
  country: (0, import_yup.string)().min(2, "Country code must be two letters.").max(2, "Country code must be two letters."),
  first_name: (0, import_yup.string)().max(50, "First name must be 50 characters or less."),
  last_name: (0, import_yup.string)().max(50, "Last name must be 50 characters or less."),
  address_2: (0, import_yup.string)().max(64, "Address must be 64 characters or less."),
  phone: (0, import_yup.string)().max(32, "Phone number must be 32 characters or less."),
  state: (0, import_yup.string)().max(24, "State must be 24 characters or less."),
  tax_id: (0, import_yup.string)().max(100, "Tax ID must be 100 characters or less."),
  zip: (0, import_yup.string)().max(16, "Zip code must be 16 characters or less.")
});
var createOAuthClientSchema = (0, import_yup.object)({
  label: (0, import_yup.string)().required("Label is required.").min(1, "Label must be between 1 and 512 characters.").max(512, "Label must be between 1 and 512 characters."),
  redirect_uri: (0, import_yup.string)().required("Redirect URI is required.")
});
var updateOAuthClientSchema = (0, import_yup.object)({
  label: (0, import_yup.string)().min(1, "Label must be between 1 and 512 characters.").max(512, "Label must be between 1 and 512 characters."),
  redirect_uri: (0, import_yup.string)()
});
var PaymentSchema = (0, import_yup.object)({
  usd: (0, import_yup.string)().required("USD payment amount is required.")
});
var CreditCardSchema = (0, import_yup.object)({
  card_number: (0, import_yup.string)().required("Credit card number is required.").min(13, "Credit card number must be between 13 and 23 characters.").max(23, "Credit card number must be between 13 and 23 characters."),
  expiry_year: (0, import_yup.number)().test(
    "length",
    "Expiration year must be 2 or 4 digits.",
    (value) => [2, 4].includes(String(value).length)
  ).required("Expiration year is required.").typeError("Expiration year must be a number.").min((/* @__PURE__ */ new Date()).getFullYear(), "Expiration year must not be in the past.").max((/* @__PURE__ */ new Date()).getFullYear() + 20, "Expiry too far in the future."),
  expiry_month: (0, import_yup.number)().required("Expiration month is required.").typeError("Expiration month must be a number.").min(1, "Expiration month must be a number from 1 to 12.").max(12, "Expiration month must be a number from 1 to 12."),
  cvv: (0, import_yup.string)().required("Security code is required.").min(3, "Security code must be between 3 and 4 characters.").max(4, "Security code must be between 3 and 4 characters.")
});
var PaymentMethodSchema = (0, import_yup.object)({
  type: (0, import_yup.mixed)().oneOf(
    ["credit_card", "payment_method_nonce"],
    "Type must be credit_card or payment_method_nonce."
  ),
  data: (0, import_yup.object)().when("type", {
    is: "credit_card",
    then: CreditCardSchema,
    otherwise: (0, import_yup.object)({
      nonce: (0, import_yup.string)().required("Payment nonce is required.")
    })
  }),
  is_default: (0, import_yup.boolean)().required(
    "You must indicate if this should be your default method of payment."
  )
});
var CreateUserSchema = (0, import_yup.object)({
  username: (0, import_yup.string)().required("Username is required.").min(3, "Username must be between 3 and 32 characters.").max(32, "Username must be between 3 and 32 characters."),
  email: (0, import_yup.string)().required("Email address is required.").email("Must be a valid email address."),
  restricted: (0, import_yup.boolean)().required(
    "You must indicate if this user should have restricted access."
  )
});
var UpdateUserSchema = (0, import_yup.object)({
  username: (0, import_yup.string)().min(3, "Username must be between 3 and 32 characters.").max(32, "Username must be between 3 and 32 characters."),
  email: (0, import_yup.string)().email("Must be a valid email address."),
  restricted: (0, import_yup.boolean)()
});
var GrantSchema = (0, import_yup.object)({
  id: (0, import_yup.number)().required("ID is required."),
  permissions: (0, import_yup.mixed)().oneOf(
    [null, "read_only", "read_write"],
    "Permissions must be null, read_only, or read_write."
  )
});
var UpdateGrantSchema = (0, import_yup.object)({
  global: (0, import_yup.object)(),
  linode: (0, import_yup.array)().of(GrantSchema),
  domain: (0, import_yup.array)().of(GrantSchema),
  nodebalancer: (0, import_yup.array)().of(GrantSchema),
  image: (0, import_yup.array)().of(GrantSchema),
  longview: (0, import_yup.array)().of(GrantSchema),
  stackscript: (0, import_yup.array)().of(GrantSchema),
  volume: (0, import_yup.array)().of(GrantSchema)
});
var UpdateAccountSettingsSchema = (0, import_yup.object)({
  network_helper: (0, import_yup.boolean)(),
  backups_enabled: (0, import_yup.boolean)(),
  managed: (0, import_yup.boolean)()
});
var PromoCodeSchema = (0, import_yup.object)({
  promo_code: (0, import_yup.string)().required("Promo code is required.").min(1, "Promo code must be between 1 and 32 characters.").max(32, "Promo code must be between 1 and 32 characters.")
});

// src/buckets.schema.ts
var import_yup2 = require("yup");
var CreateBucketSchema = (0, import_yup2.object)().shape(
  {
    label: (0, import_yup2.string)().required("Label is required.").matches(/^\S*$/, "Label must not contain spaces.").ensure().min(3, "Label must be between 3 and 63 characters.").max(63, "Label must be between 3 and 63 characters."),
    cluster: (0, import_yup2.string)().when("region", {
      is: (region) => !region || region.length === 0,
      then: (0, import_yup2.string)().required("Cluster is required.")
    }),
    region: (0, import_yup2.string)().when("cluster", {
      is: (cluster) => !cluster || cluster.length === 0,
      then: (0, import_yup2.string)().required("Region is required.")
    })
  },
  [["cluster", "region"]]
);
var UploadCertificateSchema = (0, import_yup2.object)({
  certificate: (0, import_yup2.string)().required("Certificate is required."),
  private_key: (0, import_yup2.string)().required("Private key is required.")
});
var UpdateBucketAccessSchema = (0, import_yup2.object)({
  acl: (0, import_yup2.string)().oneOf([
    "private",
    "public-read",
    "authenticated-read",
    "public-read-write"
  ]).notRequired(),
  cors_enabled: (0, import_yup2.boolean)().notRequired()
});

// src/databases.schema.ts
var import_yup3 = require("yup");
var import_yup4 = require("yup");
var LABEL_MESSAGE = "Label must be between 3 and 32 characters";
var createDatabaseSchema = (0, import_yup4.object)({
  label: (0, import_yup4.string)().required("Label is required").min(3, LABEL_MESSAGE).max(32, LABEL_MESSAGE),
  engine: (0, import_yup4.string)().required("Database Engine is required"),
  region: (0, import_yup4.string)().required("Region is required"),
  type: (0, import_yup4.string)().required("Type is required"),
  cluster_size: (0, import_yup3.number)().oneOf([1, 3], "Nodes are required").required("Nodes are required"),
  replication_type: (0, import_yup4.string)().when("engine", {
    is: (engine) => Boolean(engine.match(/mysql|postgres/g)),
    then: (0, import_yup4.string)().when("engine", {
      is: (engine) => Boolean(engine.match(/mysql/)),
      then: (0, import_yup4.string)().oneOf(["none", "semi_synch", "asynch"])
    }).when("engine", {
      is: (engine) => Boolean(engine.match(/postgres/)),
      then: (0, import_yup4.string)().oneOf(["none", "synch", "asynch"])
    }).required("Replication Type is required"),
    otherwise: (0, import_yup4.string)().notRequired().nullable(true)
  }),
  replication_commit_type: (0, import_yup4.string)().when("engine", {
    is: (engine) => Boolean(engine.match(/postgres/)),
    then: (0, import_yup4.string)().oneOf(["off", "on", "local", "remote_write", "remote_apply"]).required(),
    otherwise: (0, import_yup4.string)().notRequired().nullable(true)
  }),
  storage_engine: (0, import_yup4.string)().when("engine", {
    is: (engine) => Boolean(engine.match(/mongodb/)),
    then: (0, import_yup4.string)().oneOf(["wiredtiger", "mmapv1"]).notRequired(),
    otherwise: (0, import_yup4.string)().notRequired().nullable(true)
  }),
  compression_type: (0, import_yup4.string)().when("engine", {
    is: (engine) => Boolean(engine.match(/mongodb/)),
    then: (0, import_yup4.string)().oneOf(["none", "snappy", "zlib"]).notRequired(),
    otherwise: (0, import_yup4.string)().notRequired().nullable(true)
  })
});
var updateDatabaseSchema = (0, import_yup4.object)({
  label: (0, import_yup4.string)().notRequired().min(3, LABEL_MESSAGE).max(32, LABEL_MESSAGE),
  allow_list: (0, import_yup4.array)().of((0, import_yup4.string)()).notRequired(),
  updates: (0, import_yup4.object)().notRequired().shape({
    frequency: (0, import_yup4.string)().oneOf(["weekly", "monthly"]),
    duration: (0, import_yup3.number)(),
    hour_of_day: (0, import_yup3.number)(),
    day_of_week: (0, import_yup3.number)(),
    week_of_month: (0, import_yup3.number)().nullable(true)
  }).nullable(true),
  type: (0, import_yup4.string)().notRequired()
});

// src/domains.schema.ts
var import_yup5 = require("yup");
var importZoneSchema = (0, import_yup5.object)({
  domain: (0, import_yup5.string)().required("Domain is required."),
  remote_nameserver: (0, import_yup5.string)().required("Remote nameserver is required.")
});
var domainSchemaBase = (0, import_yup5.object)().shape({
  domain: (0, import_yup5.string)().matches(
    /([a-zA-Z0-9-_]+\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|XN--[a-zA-Z0-9]+)/,
    "Domain is not valid."
  ),
  status: (0, import_yup5.mixed)().oneOf(["disabled", "active", "edit_mode", "has_errors"]),
  tags: (0, import_yup5.array)(),
  description: (0, import_yup5.string)().min(1, "Description must be between 1 and 253 characters.").max(253, "Description must be between 1 and 253 characters."),
  retry_sec: (0, import_yup5.number)(),
  master_ips: (0, import_yup5.array)().of((0, import_yup5.string)()),
  axfr_ips: (0, import_yup5.array)().of((0, import_yup5.string)()).typeError("Must be a comma-separated list of IP addresses."),
  expire_sec: (0, import_yup5.number)(),
  refresh_sec: (0, import_yup5.number)(),
  ttl_sec: (0, import_yup5.number)()
});
var createDomainSchema = domainSchemaBase.shape({
  domain: (0, import_yup5.string)().required("Domain is required.").matches(
    /([a-zA-Z0-9-_]+\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|XN--[a-zA-Z0-9]+)/,
    "Domain is not valid."
  ),
  tags: (0, import_yup5.array)().of((0, import_yup5.string)()),
  type: (0, import_yup5.mixed)().required().oneOf(["master", "slave"]),
  soa_email: (0, import_yup5.string)().when("type", {
    is: "master",
    then: (0, import_yup5.string)().required("SOA Email is required."),
    otherwise: (0, import_yup5.string)()
  }).email("SOA Email is not valid.").trim(),
  master_ips: (0, import_yup5.array)().of((0, import_yup5.string)()).when("type", {
    is: "slave",
    then: (0, import_yup5.array)().of((0, import_yup5.string)()).compact().ensure().required("At least one primary IP address is required.").min(1, "At least one primary IP address is required."),
    otherwise: (0, import_yup5.array)().of((0, import_yup5.string)())
  })
});
var updateDomainSchema = domainSchemaBase.shape({
  domainId: (0, import_yup5.number)(),
  soa_email: (0, import_yup5.string)().email("SOA Email is not valid."),
  axfr_ips: (0, import_yup5.array)().of((0, import_yup5.string)()),
  tags: (0, import_yup5.array)().of((0, import_yup5.string)())
});

// src/firewalls.schema.ts
var import_ipaddr = __toESM(require("ipaddr.js"), 1);
var import_yup6 = require("yup");
var IP_ERROR_MESSAGE = "Must be a valid IPv4 or IPv6 address or range.";
var validateIP = (ipAddress2) => {
  if (!ipAddress2) {
    return false;
  }
  const [, mask] = ipAddress2.split("/");
  try {
    if (mask) {
      import_ipaddr.default.parseCIDR(ipAddress2);
    } else {
      import_ipaddr.default.parse(ipAddress2);
    }
  } catch (err) {
    if (ipAddress2 !== "") {
      return false;
    }
  }
  return true;
};
var CreateFirewallDeviceSchema = (0, import_yup6.object)({
  linodes: (0, import_yup6.array)().of((0, import_yup6.number)()),
  nodebalancers: (0, import_yup6.array)().of((0, import_yup6.number)())
});
var ipAddress = (0, import_yup6.string)().test({
  name: "validateIP",
  message: IP_ERROR_MESSAGE,
  test: validateIP
});
var CUSTOM_PORTS_ERROR_MESSAGE = "";
var validatePort = (port) => {
  CUSTOM_PORTS_ERROR_MESSAGE = "Ports must be an integer, range of integers, or a comma-separated list of integers.";
  if (!port) {
    CUSTOM_PORTS_ERROR_MESSAGE = "Must be 1-65535";
    return false;
  }
  const convertedPort = parseInt(port, 10);
  if (!(1 <= convertedPort && convertedPort <= 65535)) {
    CUSTOM_PORTS_ERROR_MESSAGE = "Must be 1-65535";
    return false;
  }
  if (port.startsWith("0")) {
    CUSTOM_PORTS_ERROR_MESSAGE = "Port must not have leading zeroes";
    return false;
  }
  if (String(convertedPort) !== port) {
    return false;
  }
  return true;
};
var isCustomPortsValid = (ports) => {
  const portList = (ports == null ? void 0 : ports.split(",")) || [];
  let portLimitCount = 0;
  for (const port of portList) {
    const cleanedPort = port.trim();
    if (cleanedPort.includes("-")) {
      const portRange = cleanedPort.split("-");
      if (!validatePort(portRange[0]) || !validatePort(portRange[1])) {
        return false;
      }
      if (portRange.length !== 2) {
        CUSTOM_PORTS_ERROR_MESSAGE = "Ranges must have 2 values";
        return false;
      }
      if (parseInt(portRange[0], 10) >= parseInt(portRange[1], 10)) {
        CUSTOM_PORTS_ERROR_MESSAGE = "Range must start with a smaller number and end with a larger number";
        return false;
      }
      portLimitCount += 2;
    } else {
      if (!validatePort(cleanedPort)) {
        return false;
      }
      portLimitCount++;
    }
  }
  if (portLimitCount > 15) {
    CUSTOM_PORTS_ERROR_MESSAGE = "Number of ports or port range endpoints exceeded. Max allowed is 15";
    return false;
  }
  return true;
};
var validateFirewallPorts = (0, import_yup6.string)().test({
  name: "firewall-ports",
  message: CUSTOM_PORTS_ERROR_MESSAGE,
  test: (value) => {
    if (!value) {
      return false;
    }
    try {
      isCustomPortsValid(value);
    } catch (err) {
      return false;
    }
    return true;
  }
});
var validFirewallRuleProtocol = ["ALL", "TCP", "UDP", "ICMP", "IPENCAP"];
var FirewallRuleTypeSchema = (0, import_yup6.object)().shape({
  action: (0, import_yup6.mixed)().oneOf(["ACCEPT", "DROP"]).required("Action is required"),
  protocol: (0, import_yup6.mixed)().oneOf(validFirewallRuleProtocol).required("Protocol is required."),
  ports: (0, import_yup6.string)().when("protocol", {
    is: (val) => val !== "ICMP" && val !== "IPENCAP",
    then: validateFirewallPorts,
    // Workaround to get the test to fail if ports is defined when protocol === ICMP or IPENCAP
    otherwise: (0, import_yup6.string)().test({
      name: "protocol",
      message: "Ports are not allowed for ICMP and IPENCAP protocols.",
      test: (value) => typeof value === "undefined"
    })
  }),
  addresses: (0, import_yup6.object)().shape({
    ipv4: (0, import_yup6.array)().of(ipAddress).nullable(true),
    ipv6: (0, import_yup6.array)().of(ipAddress).nullable(true)
  }).strict(true).nullable(true)
});
var FirewallRuleSchema = (0, import_yup6.object)().shape({
  inbound: (0, import_yup6.array)(FirewallRuleTypeSchema).nullable(true),
  outbound: (0, import_yup6.array)(FirewallRuleTypeSchema).nullable(true),
  inbound_policy: (0, import_yup6.mixed)().oneOf(["ACCEPT", "DROP"]).required("Inbound policy is required."),
  outbound_policy: (0, import_yup6.mixed)().oneOf(["ACCEPT", "DROP"]).required("Outbound policy is required.")
});
var CreateFirewallSchema = (0, import_yup6.object)().shape({
  label: (0, import_yup6.string)().required("Label is required.").min(3, "Label must be between 3 and 32 characters.").max(32, "Label must be between 3 and 32 characters."),
  // Label validation on the back end is more complicated, we only do basic checks here.
  tags: (0, import_yup6.array)().of((0, import_yup6.string)()),
  rules: FirewallRuleSchema
});
var UpdateFirewallSchema = (0, import_yup6.object)().shape({
  label: (0, import_yup6.string)(),
  tags: (0, import_yup6.array)().of((0, import_yup6.string)()),
  status: (0, import_yup6.string)().oneOf(["enabled", "disabled"])
  // 'deleted' is also a status but it's not settable
});
var FirewallDeviceSchema = (0, import_yup6.object)({
  type: (0, import_yup6.string)().oneOf(["linode", "nodebalancer"]).required("Device type is required."),
  id: (0, import_yup6.number)().required("ID is required.")
});

// src/images.schema.ts
var import_yup7 = require("yup");
var labelSchema = (0, import_yup7.string)().max(50, "Length must be 50 characters or less.").matches(
  /^[a-zA-Z0-9,.?\-_\s']+$/,
  "Image labels cannot contain special characters."
);
var baseImageSchema = (0, import_yup7.object)().shape({
  label: labelSchema.notRequired(),
  description: (0, import_yup7.string)().notRequired().min(1).max(65e3),
  cloud_init: (0, import_yup7.boolean)().notRequired()
});
var createImageSchema = baseImageSchema.shape({
  disk_id: (0, import_yup7.number)().typeError("Disk is required.").required("Disk is required.")
});
var uploadImageSchema = baseImageSchema.shape({
  label: labelSchema.required("Label is required."),
  region: (0, import_yup7.string)().required("Region is required.")
});
var updateImageSchema = (0, import_yup7.object)().shape({
  label: (0, import_yup7.string)().notRequired().max(50, "Length must be 50 characters or less.").matches(
    /^[a-zA-Z0-9,.?\-_\s']+$/,
    "Image labels cannot contain special characters."
  ),
  description: (0, import_yup7.string)().notRequired().max(65e3, "Length must be 65000 characters or less.")
});

// src/kubernetes.schema.ts
var import_yup8 = require("yup");
var nodePoolSchema = (0, import_yup8.object)().shape({
  type: (0, import_yup8.string)(),
  count: (0, import_yup8.number)()
});
var AutoscaleNodePoolSchema = (0, import_yup8.object)({
  enabled: (0, import_yup8.boolean)(),
  min: (0, import_yup8.number)().when("enabled", {
    is: true,
    then: (0, import_yup8.number)().required().test(
      "min",
      "Minimum must be between 1 and 99 nodes and cannot be greater than Maximum.",
      function(min) {
        if (!min) {
          return false;
        }
        if (min < 1 || min > 99) {
          return false;
        }
        if (min > this.parent["max"]) {
          return false;
        }
        return true;
      }
    )
  }),
  max: (0, import_yup8.number)().when("enabled", {
    is: true,
    then: (0, import_yup8.number)().required().min(1, "Maximum must be between 1 and 100 nodes.").max(100, "Maximum must be between 1 and 100 nodes.")
  })
});
var clusterLabelSchema = (0, import_yup8.string)().required("Label is required.").matches(
  /^[a-zA-Z0-9-]+$/,
  "Cluster labels cannot contain special characters, spaces, or underscores."
).min(3, "Length must be between 3 and 32 characters.").max(32, "Length must be between 3 and 32 characters.");
var createKubeClusterSchema = (0, import_yup8.object)().shape({
  label: clusterLabelSchema,
  region: (0, import_yup8.string)().required("Region is required."),
  k8s_version: (0, import_yup8.string)().required("Kubernetes version is required."),
  node_pools: (0, import_yup8.array)().of(nodePoolSchema).min(1, "Please add at least one node pool.")
});

// src/linodes.schema.ts
var import_yup10 = require("yup");
var import_ipaddr3 = __toESM(require("ipaddr.js"), 1);

// src/vpcs.schema.ts
var import_ipaddr2 = __toESM(require("ipaddr.js"), 1);
var import_yup9 = require("yup");
var LABEL_MESSAGE2 = "Label must be between 1 and 64 characters.";
var LABEL_REQUIRED = "Label is required";
var LABEL_REQUIREMENTS = "Must include only ASCII letters, numbers, and dashes";
var labelTestDetails = {
  testName: "no two dashes in a row",
  testMessage: "Must not contain two dashes in a row"
};
var IP_EITHER_BOTH_NOT_NEITHER = "A subnet must have either IPv4 or IPv6, or both, but not neither.";
var determineIPType = (ip) => {
  try {
    let addr;
    const [, mask] = ip.split("/");
    if (mask) {
      const parsed = import_ipaddr2.default.parseCIDR(ip);
      addr = parsed[0];
    } else {
      addr = import_ipaddr2.default.parse(ip);
    }
    return addr.kind();
  } catch (e) {
    return void 0;
  }
};
var vpcsValidateIP = ({
  value,
  shouldHaveIPMask,
  mustBeIPMask
}) => {
  if (!value) {
    return false;
  }
  const [, mask] = value.trim().split("/");
  if (mustBeIPMask) {
    const valueIsMaskOnly = value === `/${mask}`;
    return !mask ? false : import_ipaddr2.default.IPv6.subnetMaskFromPrefixLength(Number(mask)) !== null && valueIsMaskOnly && Number(mask) >= 64 && Number(mask) <= 125;
  }
  try {
    const type = determineIPType(value);
    const isIPv4 = type === "ipv4";
    const isIPv6 = type === "ipv6";
    if (!isIPv4 && !isIPv6) {
      return false;
    }
    if (isIPv4) {
      if (shouldHaveIPMask) {
        import_ipaddr2.default.IPv4.parseCIDR(value);
      } else {
        import_ipaddr2.default.IPv4.isValid(value);
        import_ipaddr2.default.IPv4.parse(value);
      }
    }
    if (isIPv6) {
      if (shouldHaveIPMask) {
        import_ipaddr2.default.IPv6.parseCIDR(value);
      } else {
        import_ipaddr2.default.IPv6.isValid(value);
        import_ipaddr2.default.IPv6.parse(value);
      }
    }
    return true;
  } catch (err) {
    return false;
  }
};
var labelValidation = (0, import_yup9.string)().test(
  labelTestDetails.testName,
  labelTestDetails.testMessage,
  (value) => !(value == null ? void 0 : value.includes("--"))
).min(1, LABEL_MESSAGE2).max(64, LABEL_MESSAGE2).matches(/[a-zA-Z0-9-]+/, LABEL_REQUIREMENTS);
var updateVPCSchema = (0, import_yup9.object)({
  label: labelValidation.notRequired(),
  description: (0, import_yup9.string)().notRequired()
});
var createSubnetSchema = (0, import_yup9.object)().shape(
  {
    label: labelValidation.required(LABEL_REQUIRED),
    ipv4: (0, import_yup9.string)().when("ipv6", {
      is: void 0,
      then: (0, import_yup9.string)().required(IP_EITHER_BOTH_NOT_NEITHER).test({
        name: "IPv4 CIDR format",
        message: "The IPv4 range must be in CIDR format",
        test: (value) => vpcsValidateIP({
          value,
          shouldHaveIPMask: true,
          mustBeIPMask: false
        })
      }),
      otherwise: (0, import_yup9.lazy)((value) => {
        switch (typeof value) {
          case "undefined":
            return (0, import_yup9.string)().notRequired().nullable();
          case "string":
            return (0, import_yup9.string)().notRequired().test({
              name: "IPv4 CIDR format",
              message: "The IPv4 range must be in CIDR format",
              test: (value2) => vpcsValidateIP({
                value: value2,
                shouldHaveIPMask: true,
                mustBeIPMask: false
              })
            });
          default:
            return (0, import_yup9.string)().notRequired().nullable();
        }
      })
    }),
    ipv6: (0, import_yup9.string)().when("ipv4", {
      is: void 0,
      then: (0, import_yup9.string)().required(IP_EITHER_BOTH_NOT_NEITHER).test({
        name: "IPv6 prefix length",
        message: "Must be the prefix length (64-125) of the IP, e.g. /64",
        test: (value) => vpcsValidateIP({
          value,
          shouldHaveIPMask: true,
          mustBeIPMask: true
        })
      }),
      otherwise: (0, import_yup9.lazy)((value) => {
        switch (typeof value) {
          case "undefined":
            return (0, import_yup9.string)().notRequired().nullable();
          case "string":
            return (0, import_yup9.string)().notRequired().test({
              name: "IPv6 prefix length",
              message: "Must be the prefix length (64-125) of the IP, e.g. /64",
              test: (value2) => vpcsValidateIP({
                value: value2,
                shouldHaveIPMask: true,
                mustBeIPMask: true
              })
            });
          default:
            return (0, import_yup9.string)().notRequired().nullable();
        }
      })
    })
  },
  [
    ["ipv6", "ipv4"],
    ["ipv4", "ipv6"]
  ]
);
var createVPCSchema = (0, import_yup9.object)({
  label: labelValidation.required(LABEL_REQUIRED),
  description: (0, import_yup9.string)(),
  region: (0, import_yup9.string)().required("Region is required"),
  subnets: (0, import_yup9.array)().of(createSubnetSchema)
});
var modifySubnetSchema = (0, import_yup9.object)({
  label: labelValidation.required(LABEL_REQUIRED)
});

// src/linodes.schema.ts
var validateIP2 = (ipAddress2) => {
  if (!ipAddress2) {
    return true;
  }
  try {
    import_ipaddr3.default.parseCIDR(ipAddress2);
  } catch (err) {
    return false;
  }
  return true;
};
var test_vpcsValidateIP = (value) => {
  if (value === void 0 || value === null) {
    return true;
  }
  return vpcsValidateIP({
    value,
    shouldHaveIPMask: false,
    mustBeIPMask: false
  });
};
var testnameDisallowedBasedOnPurpose = (allowedPurpose) => `Disallowed for non-${allowedPurpose} interfaces`;
var testmessageDisallowedBasedOnPurpose = (allowedPurpose, field) => `${field} is not allowed for interfaces that do not have a purpose set to ${allowedPurpose}.`;
var LINODE_LABEL_CHAR_REQUIREMENT = "Label must contain between 3 and 64 characters.";
var stackscript_data = (0, import_yup10.array)().of((0, import_yup10.object)()).nullable(true);
var IPv4 = (0, import_yup10.string)().notRequired().nullable().test({
  name: "validateIPv4",
  message: "Must be a valid IPv4 address, e.g. 192.168.2.0",
  test: (value) => test_vpcsValidateIP(value)
});
var IPv6 = (0, import_yup10.string)().notRequired().nullable().test({
  name: "validateIPv6",
  message: "Must be a valid IPv6 address, e.g. 2600:3c00::f03c:92ff:feeb:98f9.",
  test: (value) => test_vpcsValidateIP(value)
});
var ipv4ConfigInterface = (0, import_yup10.object)().when("purpose", {
  is: "vpc",
  then: (0, import_yup10.object)({
    vpc: IPv4,
    nat_1_1: (0, import_yup10.lazy)(
      (value) => value === "any" ? (0, import_yup10.string)().notRequired().nullable() : IPv4
    )
  }),
  otherwise: (0, import_yup10.object)().nullable().test({
    name: testnameDisallowedBasedOnPurpose("VPC"),
    message: testmessageDisallowedBasedOnPurpose("vpc", "ipv4.vpc"),
    /*
      Workaround to get test to fail if field is populated when it should not be based
      on purpose (inspired by similar approach in firewalls.schema.ts for ports field).
      Similarly-structured logic (return typeof xyz === 'undefined') throughout this
      file serves the same purpose.
    */
    test: (value) => {
      if (value == null ? void 0 : value.vpc) {
        return typeof value.vpc === "undefined";
      }
      return true;
    }
  }).test({
    name: testnameDisallowedBasedOnPurpose("VPC"),
    message: testmessageDisallowedBasedOnPurpose("vpc", "ipv4.nat_1_1"),
    test: (value) => {
      if (value == null ? void 0 : value.nat_1_1) {
        return typeof value.nat_1_1 === "undefined";
      }
      return true;
    }
  })
});
var ipv6ConfigInterface = (0, import_yup10.object)().when("purpose", {
  is: "vpc",
  then: (0, import_yup10.object)({
    vpc: IPv6
  }),
  otherwise: (0, import_yup10.object)().nullable().test({
    name: testnameDisallowedBasedOnPurpose("VPC"),
    message: testmessageDisallowedBasedOnPurpose("vpc", "ipv6.vpc"),
    test: (value) => {
      if (value == null ? void 0 : value.vpc) {
        return typeof value.vpc === "undefined";
      }
      return true;
    }
  })
});
var LinodeInterfaceSchema = (0, import_yup10.object)().shape({
  purpose: (0, import_yup10.mixed)().oneOf(
    ["public", "vlan", "vpc"],
    "Purpose must be public, vlan, or vpc."
  ),
  label: (0, import_yup10.string)().when("purpose", {
    is: "vlan",
    then: (0, import_yup10.string)().required("VLAN label is required.").min(1, "VLAN label must be between 1 and 64 characters.").max(64, "VLAN label must be between 1 and 64 characters.").matches(
      /[a-zA-Z0-9-]+/,
      "Must include only ASCII letters, numbers, and dashes"
    ),
    otherwise: (0, import_yup10.string)().when("label", {
      is: null,
      then: (0, import_yup10.string)().nullable(),
      otherwise: (0, import_yup10.string)().test({
        name: testnameDisallowedBasedOnPurpose("VLAN"),
        message: testmessageDisallowedBasedOnPurpose("vlan", "label"),
        test: (value) => typeof value === "undefined" || value === ""
      })
    })
  }),
  ipam_address: (0, import_yup10.string)().when("purpose", {
    is: "vlan",
    then: (0, import_yup10.string)().notRequired().nullable().test({
      name: "validateIPAM",
      message: "Must be a valid IPv4 range, e.g. 192.0.2.0/24.",
      test: validateIP2
    }),
    otherwise: (0, import_yup10.string)().when("ipam_address", {
      is: null,
      then: (0, import_yup10.string)().nullable(),
      otherwise: (0, import_yup10.string)().test({
        name: testnameDisallowedBasedOnPurpose("VLAN"),
        message: testmessageDisallowedBasedOnPurpose("vlan", "ipam_address"),
        test: (value) => typeof value === "undefined" || value === ""
      })
    })
  }),
  primary: (0, import_yup10.boolean)().notRequired(),
  subnet_id: (0, import_yup10.number)().when("purpose", {
    is: "vpc",
    then: (0, import_yup10.number)().transform((value) => isNaN(value) ? void 0 : value).required("Subnet is required."),
    otherwise: (0, import_yup10.number)().test({
      name: testnameDisallowedBasedOnPurpose("VPC"),
      message: testmessageDisallowedBasedOnPurpose("vpc", "subnet_id"),
      test: (value) => typeof value === "undefined"
    })
  }),
  vpc_id: (0, import_yup10.number)().when("purpose", {
    is: "vpc",
    then: (0, import_yup10.number)().required("VPC is required."),
    otherwise: (0, import_yup10.number)().test({
      name: testnameDisallowedBasedOnPurpose("VPC"),
      message: testmessageDisallowedBasedOnPurpose("vpc", "vpc_id"),
      test: (value) => typeof value === "undefined"
    })
  }),
  ipv4: ipv4ConfigInterface,
  ipv6: ipv6ConfigInterface,
  ip_ranges: (0, import_yup10.array)().of((0, import_yup10.string)()).when("purpose", {
    is: "vpc",
    then: (0, import_yup10.array)().of(
      (0, import_yup10.string)().test(
        "valid-ip-range",
        "Must be a valid IPv4 range, e.g. 192.0.2.0/24.",
        validateIP2
      )
    ).notRequired(),
    otherwise: (0, import_yup10.array)().test({
      name: testnameDisallowedBasedOnPurpose("VPC"),
      message: testmessageDisallowedBasedOnPurpose("vpc", "ip_ranges"),
      test: (value) => typeof value === "undefined"
    })
  })
});
var LinodeInterfacesSchema = (0, import_yup10.array)().of(LinodeInterfaceSchema).test(
  "unique-public-interface",
  "Only one public interface per config is allowed.",
  (list) => {
    if (!list) {
      return true;
    }
    return list.filter((thisSlot) => thisSlot.purpose === "public").length <= 1;
  }
);
var UpdateConfigInterfaceOrderSchema = (0, import_yup10.object)({
  ids: (0, import_yup10.array)().of((0, import_yup10.number)()).required("The list of interface IDs is required.")
});
var UpdateConfigInterfaceSchema = (0, import_yup10.object)({
  primary: (0, import_yup10.boolean)().notRequired(),
  ipv4: (0, import_yup10.object)().notRequired().shape({
    vpc: IPv4,
    nat_1_1: (0, import_yup10.lazy)(
      (value) => value === "any" ? (0, import_yup10.string)().notRequired().nullable() : IPv4
    )
  }),
  ipv6: (0, import_yup10.object)().notRequired().nullable().shape({
    vpc: IPv6
  }),
  ip_ranges: (0, import_yup10.array)().of((0, import_yup10.string)().test(validateIP2)).max(1).notRequired()
});
var ResizeLinodeDiskSchema = (0, import_yup10.object)({
  size: (0, import_yup10.number)().required("Size is required.").min(1)
});
var UpdateLinodePasswordSchema = (0, import_yup10.object)({
  password: (0, import_yup10.string)().required("Password is required.")
  // .concat(rootPasswordValidation)
});
var MetadataSchema = (0, import_yup10.object)({
  user_data: (0, import_yup10.string)().notRequired().nullable(true)
});
var PlacementGroupPayloadSchema = (0, import_yup10.object)({
  id: (0, import_yup10.number)().notRequired().nullable(true)
});
var DiskEncryptionSchema = (0, import_yup10.object)({
  disk_encryption: (0, import_yup10.string)().oneOf(["enabled", "disabled"]).nullable().notRequired()
});
var CreateLinodeSchema = (0, import_yup10.object)({
  type: (0, import_yup10.string)().ensure().required("Plan is required."),
  region: (0, import_yup10.string)().ensure().required("Region is required."),
  stackscript_id: (0, import_yup10.number)().nullable().notRequired(),
  backup_id: (0, import_yup10.number)().nullable().notRequired(),
  swap_size: (0, import_yup10.number)().notRequired(),
  image: (0, import_yup10.string)().when("stackscript_id", {
    is: (value) => value !== void 0,
    then: (0, import_yup10.string)().ensure().required("Image is required."),
    otherwise: (0, import_yup10.string)().nullable().notRequired()
  }),
  authorized_keys: (0, import_yup10.array)().of((0, import_yup10.string)()).notRequired(),
  backups_enabled: (0, import_yup10.boolean)().notRequired(),
  stackscript_data,
  booted: (0, import_yup10.boolean)().notRequired(),
  label: (0, import_yup10.string)().transform((v) => v === "" ? void 0 : v).notRequired().min(3, LINODE_LABEL_CHAR_REQUIREMENT).max(64, LINODE_LABEL_CHAR_REQUIREMENT),
  tags: (0, import_yup10.array)().of((0, import_yup10.string)()).notRequired(),
  private_ip: (0, import_yup10.boolean)().notRequired(),
  authorized_users: (0, import_yup10.array)().of((0, import_yup10.string)()).notRequired(),
  root_pass: (0, import_yup10.string)().when("image", {
    is: (value) => Boolean(value),
    then: (0, import_yup10.string)().required(
      "You must provide a root password when deploying from an image."
    ),
    // .concat(rootPasswordValidation),
    otherwise: (0, import_yup10.string)().notRequired()
  }),
  interfaces: LinodeInterfacesSchema,
  metadata: MetadataSchema,
  firewall_id: (0, import_yup10.number)().nullable().notRequired(),
  placement_group: PlacementGroupPayloadSchema,
  disk_encryption: DiskEncryptionSchema
});
var alerts = (0, import_yup10.object)({
  cpu: (0, import_yup10.number)().typeError("CPU Usage must be a number").min(0, "Must be between 0 and 4800").max(4800, "Must be between 0 and 4800"),
  network_in: (0, import_yup10.number)(),
  network_out: (0, import_yup10.number)(),
  transfer_quota: (0, import_yup10.number)(),
  io: (0, import_yup10.number)()
}).notRequired();
var schedule = (0, import_yup10.object)({
  day: (0, import_yup10.mixed)().oneOf(
    [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    "Invalid day value."
  ),
  window: (0, import_yup10.mixed)().oneOf(
    [
      "W0",
      "W2",
      "W4",
      "W6",
      "W8",
      "W10",
      "W12",
      "W14",
      "W16",
      "W18",
      "W20",
      "W22",
      "W24"
    ],
    "Invalid schedule value."
  )
});
var backups = (0, import_yup10.object)({
  schedule,
  enabled: (0, import_yup10.boolean)()
});
var UpdateLinodeSchema = (0, import_yup10.object)({
  label: (0, import_yup10.string)().transform((v) => v === "" ? void 0 : v).notRequired().min(3, LINODE_LABEL_CHAR_REQUIREMENT).max(64, LINODE_LABEL_CHAR_REQUIREMENT),
  tags: (0, import_yup10.array)().of((0, import_yup10.string)()).notRequired(),
  watchdog_enabled: (0, import_yup10.boolean)().notRequired(),
  alerts,
  backups
});
var SSHKeySchema = (0, import_yup10.object)({
  id: (0, import_yup10.number)(),
  label: (0, import_yup10.string)(),
  ssh_key: (0, import_yup10.string)(),
  created: (0, import_yup10.string)()
});
var RebuildLinodeSchema = (0, import_yup10.object)().shape({
  image: (0, import_yup10.string)().required("An image is required."),
  root_pass: (0, import_yup10.string)().required("Password is required."),
  authorized_keys: (0, import_yup10.array)().of(SSHKeySchema),
  authorized_users: (0, import_yup10.array)().of((0, import_yup10.string)()),
  stackscript_id: (0, import_yup10.number)().notRequired(),
  stackscript_data,
  booted: (0, import_yup10.boolean)().notRequired(),
  metadata: MetadataSchema,
  disk_encryption: DiskEncryptionSchema
});
var RebuildLinodeFromStackScriptSchema = RebuildLinodeSchema.shape({
  stackscript_id: (0, import_yup10.number)().required("A StackScript is required.")
});
var IPAllocationSchema = (0, import_yup10.object)({
  type: (0, import_yup10.string)().required("IP address type (IPv4) is required.").oneOf(["ipv4"], "Only IPv4 addresses can be allocated."),
  public: (0, import_yup10.boolean)().required("Must specify public or private IP address.")
});
var CreateSnapshotSchema = (0, import_yup10.object)({
  label: (0, import_yup10.string)().required("A snapshot label is required.").min(1, "Label must be between 1 and 255 characters.").max(255, "Label must be between 1 and 255 characters.")
});
var device = (0, import_yup10.object)({
  disk_id: (0, import_yup10.number)().nullable(true),
  volume_id: (0, import_yup10.number)().nullable(true)
}).nullable(true);
var devices = (0, import_yup10.object)({
  sda: device,
  sdb: device,
  sdc: device,
  sdd: device,
  sde: device,
  sdf: device,
  sdg: device,
  sdh: device
});
var helpers = (0, import_yup10.object)({
  updatedb_disabled: (0, import_yup10.boolean)(),
  distro: (0, import_yup10.boolean)(),
  modules_dep: (0, import_yup10.boolean)(),
  network: (0, import_yup10.boolean)(),
  devtmpfs_automount: (0, import_yup10.boolean)()
});
var CreateLinodeConfigSchema = (0, import_yup10.object)({
  label: (0, import_yup10.string)().required("Label is required.").min(1, "Label must be between 1 and 48 characters.").max(48, "Label must be between 1 and 48 characters."),
  devices: devices.required("A list of devices is required."),
  kernel: (0, import_yup10.string)(),
  comments: (0, import_yup10.string)(),
  memory_limit: (0, import_yup10.number)(),
  run_level: (0, import_yup10.mixed)().oneOf(["default", "single", "binbash"]),
  virt_mode: (0, import_yup10.mixed)().oneOf(["paravirt", "fullvirt"]),
  helpers,
  root_device: (0, import_yup10.string)(),
  interfaces: LinodeInterfacesSchema
});
var UpdateLinodeConfigSchema = (0, import_yup10.object)({
  label: (0, import_yup10.string)().min(1, "Label must be between 1 and 48 characters.").max(48, "Label must be between 1 and 48 characters."),
  devices,
  kernel: (0, import_yup10.string)(),
  comments: (0, import_yup10.string)(),
  memory_limit: (0, import_yup10.number)(),
  run_level: (0, import_yup10.mixed)().oneOf(["default", "single", "binbash"]),
  virt_mode: (0, import_yup10.mixed)().oneOf(["paravirt", "fullvirt"]),
  helpers,
  root_device: (0, import_yup10.string)(),
  interfaces: LinodeInterfacesSchema
});
var CreateLinodeDiskSchema = (0, import_yup10.object)({
  size: (0, import_yup10.number)().required("Disk size is required."),
  label: (0, import_yup10.string)().required("A disk label is required.").min(1, "Label must be between 1 and 48 characters.").max(48, "Label must be between 1 and 48 characters."),
  filesystem: (0, import_yup10.mixed)().oneOf(["raw", "swap", "ext3", "ext4", "initrd"]),
  read_only: (0, import_yup10.boolean)(),
  image: (0, import_yup10.string)(),
  authorized_keys: (0, import_yup10.array)().of((0, import_yup10.string)()),
  authorized_users: (0, import_yup10.array)().of((0, import_yup10.string)()),
  root_pass: (0, import_yup10.string)().when("image", {
    is: (value) => Boolean(value),
    then: (0, import_yup10.string)().required(
      "You must provide a root password when deploying from an image."
    ),
    // .concat(rootPasswordValidation),
    otherwise: (0, import_yup10.string)().notRequired()
  }),
  stackscript_id: (0, import_yup10.number)(),
  stackscript_data
});
var UpdateLinodeDiskSchema = (0, import_yup10.object)({
  label: (0, import_yup10.string)().notRequired().min(1, "Label must be between 1 and 48 characters.").max(48, "Label must be between 1 and 48 characters."),
  filesystem: (0, import_yup10.mixed)().notRequired().oneOf(["raw", "swap", "ext3", "ext4", "initrd"])
});
var CreateLinodeDiskFromImageSchema = CreateLinodeDiskSchema.clone().shape(
  {
    image: (0, import_yup10.string)().required("An image is required.")
  }
);

// src/loadbalancers.schema.ts
var import_yup11 = require("yup");
var LABEL_REQUIRED2 = "Label is required.";
var matchFieldOptions = [
  "always_match",
  "path_prefix",
  "path_regex",
  "query",
  "header",
  "method"
];
var CreateCertificateSchema = (0, import_yup11.object)({
  certificate: (0, import_yup11.string)().required("Certificate is required."),
  key: (0, import_yup11.string)().when("type", {
    is: "downstream",
    then: (0, import_yup11.string)().required("Private Key is required.")
  }),
  label: (0, import_yup11.string)().required(LABEL_REQUIRED2),
  type: (0, import_yup11.string)().oneOf(["downstream", "ca"]).required("Type is required.")
});
var UpdateCertificateSchema = (0, import_yup11.object)().shape(
  {
    certificate: (0, import_yup11.string)(),
    key: (0, import_yup11.string)().when(["type", "certificate"], {
      is: (type, certificate) => type === "downstream" && certificate,
      then: (0, import_yup11.string)().required("Private Key is required")
    }),
    label: (0, import_yup11.string)().min(1, "Label must not be empty."),
    type: (0, import_yup11.string)().oneOf(["downstream", "ca"])
  },
  [["certificate", "key"]]
);
var CertificateEntrySchema = (0, import_yup11.object)({
  id: (0, import_yup11.number)().typeError("Certificate ID must be a number.").required("Certificate ID is required.").min(0, "Certificate ID is required."),
  hostname: (0, import_yup11.string)().required("A Host Header is required.")
});
var EndpointSchema = (0, import_yup11.object)({
  ip: (0, import_yup11.string)().required("IP is required."),
  host: (0, import_yup11.string)().nullable(),
  port: (0, import_yup11.number)().required("Port is required.").min(1, "Port must be greater than 0.").max(65535, "Port must be less than or equal to 65535."),
  rate_capacity: (0, import_yup11.number)().required("Rate Capacity is required.")
});
var HealthCheckSchema = (0, import_yup11.object)({
  protocol: (0, import_yup11.string)().oneOf(["http", "tcp"]),
  interval: (0, import_yup11.number)().typeError("Interval must be a number.").min(1, "Interval must be greater than zero."),
  timeout: (0, import_yup11.number)().typeError("Timeout must be a number.").min(1, "Timeout must be greater than zero."),
  unhealthy_threshold: (0, import_yup11.number)().typeError("Unhealthy Threshold must be a number.").min(1, "Unhealthy Threshold must be greater than zero."),
  healthy_threshold: (0, import_yup11.number)().typeError("Healthy Threshold must be a number.").min(1, "Healthy Threshold must be greater than zero."),
  path: (0, import_yup11.string)().nullable(),
  host: (0, import_yup11.string)().when("protocol", {
    is: "tcp",
    then: (o) => o.nullable(),
    otherwise: (o) => o.required("Health Check host is required.")
  })
});
var CreateServiceTargetSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().required(LABEL_REQUIRED2),
  protocol: (0, import_yup11.string)().oneOf(["tcp", "http", "https"]).required(),
  endpoints: (0, import_yup11.array)(EndpointSchema).required(),
  certificate_id: (0, import_yup11.string)().nullable(),
  load_balancing_policy: (0, import_yup11.string)().required().oneOf(["round_robin", "least_request", "ring_hash", "random", "maglev"]),
  healthcheck: HealthCheckSchema
});
var UpdateServiceTargetSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().min(1, "Label must not be empty."),
  protocol: (0, import_yup11.string)().oneOf(["tcp", "http", "https"]),
  endpoints: (0, import_yup11.array)(EndpointSchema),
  certificate_id: (0, import_yup11.number)().nullable(),
  load_balancing_policy: (0, import_yup11.string)().oneOf([
    "round_robin",
    "least_request",
    "ring_hash",
    "random",
    "maglev"
  ]),
  healthcheck: HealthCheckSchema
});
var CreateRouteSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().required(LABEL_REQUIRED2),
  protocol: (0, import_yup11.string)().oneOf(["http", "tcp"])
});
var RouteServiceTargetSchema = (0, import_yup11.object)({
  id: (0, import_yup11.number)().min(0, "Service Target ID is required.").required("Service Target ID is required."),
  percentage: (0, import_yup11.number)().min(0, "Percent must be greater than or equal to 0.").max(100, "Percent must be less than or equal to 100.").typeError("Percent must be a number.").required("Percent is required.")
});
var MatchConditionSchema = (0, import_yup11.object)({
  hostname: (0, import_yup11.string)().nullable(),
  match_field: (0, import_yup11.string)().oneOf(matchFieldOptions).required("Match field is required."),
  match_value: (0, import_yup11.string)().required("Match value is required."),
  session_stickiness_cookie: (0, import_yup11.string)().nullable(),
  session_stickiness_ttl: (0, import_yup11.number)().min(0, "TTL must be greater than or equal to 0.").typeError("TTL must be a number.").nullable()
});
var TCPRuleSchema = (0, import_yup11.object)({
  service_targets: (0, import_yup11.array)(RouteServiceTargetSchema).test(
    "sum-of-percentage",
    "The sum of the percentages must be 100",
    (serviceTargets) => {
      if (!serviceTargets || serviceTargets.length === 0) {
        return true;
      }
      const sum = serviceTargets.reduce((acc, serviceTarget) => {
        var _a;
        return acc + ((_a = serviceTarget == null ? void 0 : serviceTarget.percentage) != null ? _a : 0);
      }, 0);
      return sum === 100;
    }
  ).min(1, "Rules must have at least 1 Service Target.").required()
});
var HTTPRuleSchema = TCPRuleSchema.concat(
  (0, import_yup11.object)({
    match_condition: MatchConditionSchema
  })
);
var UpdateRouteSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().min(1, "Label must not be empty."),
  protocol: (0, import_yup11.string)().oneOf(["tcp", "http"]),
  rules: (0, import_yup11.array)().when("protocol", {
    is: "tcp",
    then: (o) => o.of(TCPRuleSchema),
    otherwise: (o) => o.of(HTTPRuleSchema)
  })
});
var UpdateConfigurationSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().min(1, "Label must not be empty."),
  port: (0, import_yup11.number)().min(1, "Port must be greater than 0.").max(65535, "Port must be less than or equal to 65535.").typeError("Port must be a number."),
  protocol: (0, import_yup11.string)().oneOf(["tcp", "http", "https"]),
  certificates: (0, import_yup11.array)().when("protocol", {
    is: "https",
    then: (o) => o.of(CertificateEntrySchema).min(1, "Certificates must not be empty for HTTPS configurations.").required(),
    otherwise: (o) => o.max(0).notRequired()
  }),
  route_ids: (0, import_yup11.array)().of((0, import_yup11.number)())
});
var CreateConfigurationSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().min(1, "Label must not be empty.").required("Label is required."),
  port: (0, import_yup11.number)().min(1, "Port must be greater than 0.").max(65535, "Port must be less than or equal to 65535.").typeError("Port must be a number.").required("Port is required."),
  protocol: (0, import_yup11.string)().oneOf(["tcp", "http", "https"]).required(),
  certificates: (0, import_yup11.array)().when("protocol", {
    is: "https",
    then: (o) => o.of(CertificateEntrySchema).min(1, "Certificates must not be empty for HTTPS configurations.").required(),
    otherwise: (o) => o.max(0).notRequired()
  }),
  route_ids: (0, import_yup11.array)().of((0, import_yup11.number)())
});
var CreateLoadBalancerEndpointSchema = (0, import_yup11.object)({
  ip: (0, import_yup11.string)().required(),
  host: (0, import_yup11.string)(),
  port: (0, import_yup11.number)().integer().required(),
  rate_capacity: (0, import_yup11.number)().integer().required()
});
var CreateLoadBalancerServiceTargetSchema = (0, import_yup11.object)({
  percentage: (0, import_yup11.number)().integer().required(),
  label: (0, import_yup11.string)().required(),
  endpoints: (0, import_yup11.array)().of(CreateLoadBalancerEndpointSchema).required(),
  certificate_id: (0, import_yup11.number)().integer().nullable(),
  load_balancing_policy: (0, import_yup11.string)().oneOf(["round_robin", "least_request", "ring_hash", "random", "maglev"]).required(),
  healthcheck: HealthCheckSchema.required()
});
var CreateLoadBalancerRuleSchema = (0, import_yup11.object)({
  match_condition: (0, import_yup11.object)().shape({
    hostname: (0, import_yup11.string)().nullable(),
    match_field: (0, import_yup11.string)().oneOf(matchFieldOptions).required(),
    match_value: (0, import_yup11.string)().required(),
    session_stickiness_cookie: (0, import_yup11.string)().nullable(),
    session_stickiness_ttl: (0, import_yup11.number)().integer().nullable()
  }),
  service_targets: (0, import_yup11.array)().of(CreateLoadBalancerServiceTargetSchema).required()
});
var ConfigurationSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().required(LABEL_REQUIRED2),
  port: (0, import_yup11.number)().min(1, "Port must be greater than 0.").max(65535, "Port must be less than or equal to 65535.").typeError("Port must be a number.").required("Port is required."),
  protocol: (0, import_yup11.string)().oneOf(["tcp", "http", "https"]).required(),
  certificates: (0, import_yup11.array)().when("protocol", {
    is: (val) => val === "https",
    then: (o) => o.of(CertificateEntrySchema).required(),
    otherwise: (o) => o.notRequired()
  }),
  routes: (0, import_yup11.array)().when("protocol", {
    is: "tcp",
    then: (o) => o.of(
      (0, import_yup11.object)({
        label: (0, import_yup11.string)().required(LABEL_REQUIRED2),
        protocol: (0, import_yup11.string)().oneOf(["tcp"]).required(),
        rules: (0, import_yup11.array)().of(CreateLoadBalancerRuleSchema).required()
      })
    ),
    otherwise: (o) => o.of(
      (0, import_yup11.object)({
        label: (0, import_yup11.string)().required(),
        protocol: (0, import_yup11.string)().oneOf(["http"]).required(),
        rules: (0, import_yup11.array)().of(CreateLoadBalancerRuleSchema).required()
      })
    )
  })
});
var CreateLoadBalancerSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().min(1, "Label must not be empty.").required(LABEL_REQUIRED2),
  // tags: array().of(string()), // TODO: ACLB - Should confirm on this with API team. Assuming this will be out of scope for Beta.
  regions: (0, import_yup11.array)().of((0, import_yup11.string)()).required(),
  configurations: (0, import_yup11.array)().of(ConfigurationSchema)
});
var CreateBasicLoadbalancerSchema = (0, import_yup11.object)({
  label: (0, import_yup11.string)().min(1, "Label must not be empty.").required("Label is required")
});

// src/longview.schema.ts
var import_yup12 = require("yup");
var longviewClientCreate = (0, import_yup12.object)().shape({
  label: (0, import_yup12.string)().min(3, "Label must be between 3 and 32 characters.").max(32, "Label must be between 3 and 32 characters.")
});

// src/managed.schema.ts
var import_yup13 = require("yup");
var createServiceMonitorSchema = (0, import_yup13.object)().shape({
  label: (0, import_yup13.string)().required("Label is required.").min(3, "Label must be between 3 and 64 characters.").max(64, "Label must be between 3 and 64 characters."),
  service_type: (0, import_yup13.mixed)().required("Monitor type is required.").oneOf(["url", "tcp"]),
  address: (0, import_yup13.string)().required("URL is required."),
  timeout: (0, import_yup13.number)().required("Timeout is required."),
  credentials: (0, import_yup13.array)().of((0, import_yup13.number)()).notRequired(),
  notes: (0, import_yup13.string)().notRequired(),
  consultation_group: (0, import_yup13.string)().notRequired(),
  body: (0, import_yup13.string)().notRequired().max(100, "Body must be 100 characters or less.")
});
var sshSettingSchema = (0, import_yup13.object)().shape({
  access: (0, import_yup13.boolean)(),
  user: (0, import_yup13.string)().max(32, "User must be 32 characters or less."),
  ip: (0, import_yup13.string)(),
  port: (0, import_yup13.number)().min(1, "Port must be between 1 and 65535.").max(65535, "Port must be between 1 and 65535.")
});
var updateManagedLinodeSchema = (0, import_yup13.object)({
  ssh: sshSettingSchema
});
var credentialLabel = (0, import_yup13.string)().min(2, "Label must be between 2 and 75 characters.").max(75, "Label must be between 2 and 75 characters.");
var credentialPassword = (0, import_yup13.string)().notRequired().max(5e3, "Password must be 5000 characters or less.");
var credentialUsername = (0, import_yup13.string)().notRequired().max(5e3, "Username must be 5000 characters or less.");
var createCredentialSchema = (0, import_yup13.object)().shape({
  label: credentialLabel.required("Label is required."),
  username: credentialUsername,
  password: credentialPassword
});
var updateCredentialSchema = (0, import_yup13.object)().shape({
  label: credentialLabel.required("Label is required.")
});
var updatePasswordSchema = (0, import_yup13.object)().shape({
  username: credentialUsername,
  password: credentialPassword.required("Password is required.")
});
var createContactSchema = (0, import_yup13.object)().shape({
  name: (0, import_yup13.string)().required("Name is required.").min(2, "Name must be between 2 and 64 characters.").max(64, "Name must be between 2 and 64 characters."),
  email: (0, import_yup13.string)().required("E-mail is required.").min(6, "E-mail must be between 6 and 100 characters").max(100, "E-mail must be between 6 and 100 characters").email("Invalid e-mail address"),
  phone: (0, import_yup13.object)().shape({
    primary: (0, import_yup13.string)().nullable(true).notRequired(),
    secondary: (0, import_yup13.string)().nullable(true).notRequired()
  }).notRequired(),
  group: (0, import_yup13.string)().notRequired().nullable(true).min(2, "Group must be between 2 and 50 characters.").max(50, "Group must be between 2 and 50 characters.")
});

// src/networking.schema.ts
var import_yup14 = require("yup");
var updateIPSchema = (0, import_yup14.object)().shape({
  rdns: (0, import_yup14.string)().notRequired().nullable(true)
});
var allocateIPSchema = (0, import_yup14.object)().shape({
  type: (0, import_yup14.string)().required().matches(
    /^ipv4$/,
    "Only IPv4 address may be allocated through this endpoint."
  ),
  public: (0, import_yup14.boolean)().required(),
  linode_id: (0, import_yup14.number)().required()
});
var assignAddressesSchema = (0, import_yup14.object)().shape({
  region: (0, import_yup14.string)().required(),
  assignments: (0, import_yup14.array)().of((0, import_yup14.object)()).required()
});
var shareAddressesSchema = (0, import_yup14.object)().shape({
  linode_id: (0, import_yup14.number)().required(),
  ips: (0, import_yup14.array)().of((0, import_yup14.string)())
});

// src/nodebalancers.schema.ts
var import_yup15 = require("yup");
var PORT_WARNING = "Port must be between 1 and 65535.";
var LABEL_WARNING = "Label must be between 3 and 32 characters.";
var nodeBalancerConfigNodeSchema = (0, import_yup15.object)({
  label: (0, import_yup15.string)().matches(
    /^[a-zA-Z0-9.\-_]+$/,
    "Label may only contain letters, numbers, periods, dashes, and underscores."
  ).min(3, "Label should be between 3 and 32 characters.").max(32, "Label should be between 3 and 32 characters.").required("Label is required."),
  address: (0, import_yup15.string)().typeError("IP address is required.").required("IP address is required.").matches(
    /^192\.168\.\d{1,3}\.\d{1,3}$/,
    "Must be a valid private IPv4 address."
  ),
  port: (0, import_yup15.number)().typeError("Port must be a number.").required("Port is required.").min(1, PORT_WARNING).max(65535, PORT_WARNING),
  weight: (0, import_yup15.number)().typeError("Weight must be a number.").min(1, `Weight must be between 1 and 255.`).max(255, `Weight must be between 1 and 255.`),
  mode: (0, import_yup15.mixed)().oneOf(["accept", "reject", "backup", "drain"])
});
var createNodeBalancerConfigSchema = (0, import_yup15.object)({
  algorithm: (0, import_yup15.mixed)().oneOf(["roundrobin", "leastconn", "source"]),
  check_attempts: (0, import_yup15.number)(),
  check_body: (0, import_yup15.string)().when("check", {
    is: "http_body",
    then: (0, import_yup15.string)().required("An HTTP body regex is required.")
  }),
  check_interval: (0, import_yup15.number)().typeError("Check interval must be a number."),
  check_passive: (0, import_yup15.boolean)(),
  check_path: (0, import_yup15.string)().matches(/\/.*/).when("check", {
    is: "http",
    then: (0, import_yup15.string)().required("An HTTP path is required.")
  }).when("check", {
    is: "http_body",
    then: (0, import_yup15.string)().required("An HTTP path is required.")
  }),
  proxy_protocol: (0, import_yup15.string)().oneOf(["none", "v1", "v2"]),
  check_timeout: (0, import_yup15.number)().typeError("Timeout must be a number.").integer(),
  check: (0, import_yup15.mixed)().oneOf(["none", "connection", "http", "http_body"]),
  cipher_suite: (0, import_yup15.mixed)().oneOf(["recommended", "legacy"]),
  port: (0, import_yup15.number)().integer().required("Port is required").min(1, PORT_WARNING).max(65535, PORT_WARNING),
  protocol: (0, import_yup15.mixed)().oneOf(["http", "https", "tcp"]),
  ssl_key: (0, import_yup15.string)().when("protocol", {
    is: "https",
    then: (0, import_yup15.string)().required("SSL key is required when using HTTPS.")
  }),
  ssl_cert: (0, import_yup15.string)().when("protocol", {
    is: "https",
    then: (0, import_yup15.string)().required("SSL certificate is required when using HTTPS.")
  }),
  stickiness: (0, import_yup15.mixed)().oneOf(["none", "table", "http_cookie"]),
  nodes: (0, import_yup15.array)().of(nodeBalancerConfigNodeSchema).required().min(1, "You must provide at least one back end node.")
});
var UpdateNodeBalancerConfigSchema = (0, import_yup15.object)({
  algorithm: (0, import_yup15.mixed)().oneOf(["roundrobin", "leastconn", "source"]),
  check_attempts: (0, import_yup15.number)(),
  check_body: (0, import_yup15.string)().when("check", {
    is: "http_body",
    then: (0, import_yup15.string)().required("An HTTP body regex is required.")
  }),
  check_interval: (0, import_yup15.number)().typeError("Check interval must be a number."),
  check_passive: (0, import_yup15.boolean)(),
  check_path: (0, import_yup15.string)().matches(/\/.*/).when("check", {
    is: "http",
    then: (0, import_yup15.string)().required("An HTTP path is required.")
  }).when("check", {
    is: "http_body",
    then: (0, import_yup15.string)().required("An HTTP path is required.")
  }),
  proxy_protocol: (0, import_yup15.string)().oneOf(["none", "v1", "v2"]),
  check_timeout: (0, import_yup15.number)().typeError("Timeout must be a number.").integer(),
  check: (0, import_yup15.mixed)().oneOf(["none", "connection", "http", "http_body"]),
  cipher_suite: (0, import_yup15.mixed)().oneOf(["recommended", "legacy"]),
  port: (0, import_yup15.number)().typeError("Port must be a number.").integer().min(1, PORT_WARNING).max(65535, PORT_WARNING),
  protocol: (0, import_yup15.mixed)().oneOf(["http", "https", "tcp"]),
  ssl_key: (0, import_yup15.string)().when("protocol", {
    is: "https",
    then: (0, import_yup15.string)().required()
  }),
  ssl_cert: (0, import_yup15.string)().when("protocol", {
    is: "https",
    then: (0, import_yup15.string)().required()
  }),
  stickiness: (0, import_yup15.mixed)().oneOf(["none", "table", "http_cookie"]),
  nodes: (0, import_yup15.array)().of(nodeBalancerConfigNodeSchema)
});
var NodeBalancerSchema = (0, import_yup15.object)({
  label: (0, import_yup15.string)().required("Label is required.").min(3, LABEL_WARNING).max(32, LABEL_WARNING).matches(
    /^[a-zA-Z0-9-_]+$/,
    "Label can't contain special characters or spaces."
  ),
  client_conn_throttle: (0, import_yup15.number)().typeError("Must be a number."),
  region: (0, import_yup15.string)().required("Region is required."),
  configs: (0, import_yup15.array)().of(createNodeBalancerConfigSchema).test("unique", "Port must be unique.", function(value) {
    if (!value) {
      return true;
    }
    const ports = [];
    const configs = value.reduce(
      (prev, value2, idx) => {
        if (!value2.port) {
          return prev;
        }
        if (!ports.includes(value2.port)) {
          ports.push(value2.port);
          return prev;
        }
        return [...prev, idx];
      },
      []
    );
    if (configs.length === 0) {
      return true;
    }
    const configStrings = configs.map(
      (config) => `configs[${config}].port`
    );
    throw this.createError({
      path: configStrings.join("|"),
      message: "Port must be unique."
    });
  })
});
var UpdateNodeBalancerSchema = (0, import_yup15.object)({
  label: (0, import_yup15.string)().min(3, LABEL_WARNING).max(32, LABEL_WARNING).matches(
    /^[a-zA-Z0-9-_]+$/,
    "Label can't contain special characters or spaces."
  ),
  client_conn_throttle: (0, import_yup15.number)().typeError("Must be a number."),
  region: (0, import_yup15.string)()
});

// src/objectStorageKeys.schema.ts
var import_yup16 = require("yup");
var labelErrorMessage = "Label must be between 3 and 50 characters.";
var createObjectStorageKeysSchema = (0, import_yup16.object)({
  label: (0, import_yup16.string)().required("Label is required.").min(3, labelErrorMessage).max(50, labelErrorMessage).trim(),
  regions: (0, import_yup16.array)().of((0, import_yup16.string)()).min(1, "Select at least one region to continue").notRequired()
});
var updateObjectStorageKeysSchema = (0, import_yup16.object)({
  label: (0, import_yup16.string)().notRequired().min(3, labelErrorMessage).max(50, labelErrorMessage).trim(),
  regions: (0, import_yup16.array)().of((0, import_yup16.string)()).min(
    1,
    `Select at least one region. To remove all regions, use 'Revoke' in the actions menu and remove the access key.`
  ).notRequired()
});

// src/placement-groups.schema.ts
var import_yup17 = require("yup");
var labelValidation2 = (0, import_yup17.string)().required("Label is required.").min(3, "Label must be between 3 and 32 characters.").max(32, "Label must be between 3 and 32 characters.");
var createPlacementGroupSchema = (0, import_yup17.object)({
  label: labelValidation2,
  affinity_type: (0, import_yup17.string)().required("Affinity type is required."),
  region: (0, import_yup17.string)().required("Region is required."),
  is_strict: (0, import_yup17.boolean)().required("Is strict is required.")
});
var updatePlacementGroupSchema = (0, import_yup17.object)({
  label: labelValidation2
});

// src/profile.schema.ts
var import_yup18 = require("yup");
var import_libphonenumber_js = require("libphonenumber-js");
var createPersonalAccessTokenSchema = (0, import_yup18.object)({
  scopes: (0, import_yup18.string)(),
  expiry: (0, import_yup18.string)(),
  label: (0, import_yup18.string)().min(1, "Label must be between 1 and 100 characters.").max(100, "Label must be between 1 and 100 characters.")
});
var createSSHKeySchema = (0, import_yup18.object)({
  label: (0, import_yup18.string)().required("Label is required.").min(1, "Label must be between 1 and 64 characters.").max(64, "Label must be between 1 and 64 characters.").trim(),
  ssh_key: (0, import_yup18.string)()
});
var updateSSHKeySchema = (0, import_yup18.object)({
  label: (0, import_yup18.string)().required("Label is required.").min(1, "Label must be between 1 and 64 characters.").max(64, "Label must be between 1 and 64 characters.").trim()
});
var updateProfileSchema = (0, import_yup18.object)({
  email: (0, import_yup18.string)().email(),
  timezone: (0, import_yup18.string)(),
  email_notifications: (0, import_yup18.boolean)(),
  authorized_keys: (0, import_yup18.array)().of((0, import_yup18.string)()),
  restricted: (0, import_yup18.boolean)(),
  two_factor_auth: (0, import_yup18.boolean)(),
  lish_auth_method: (0, import_yup18.string)().oneOf(["password_keys", "keys_only", "disabled"]),
  authentication_type: (0, import_yup18.string)().oneOf(["password", "github"])
});
var SendCodeToPhoneNumberSchema = (0, import_yup18.object)({
  iso_code: (0, import_yup18.string)().required(),
  phone_number: (0, import_yup18.string)().test(
    "is-phone-number",
    "Not a valid phone number",
    (phone_number, context) => {
      const { iso_code } = context.parent;
      if (!phone_number) {
        return false;
      }
      return (0, import_libphonenumber_js.isPossiblePhoneNumber)(phone_number, iso_code);
    }
  )
});
var VerifyPhoneNumberCodeSchema = (0, import_yup18.object)({
  otp_code: (0, import_yup18.string)().required("Verification Code is required.").test(
    "digits only",
    "The verification code must only contain digits.",
    (value) => {
      if (!value) {
        return true;
      }
      return /^\d+$/.test(value);
    }
  )
});
var SecurityQuestionsSchema = (0, import_yup18.object)({
  security_questions: (0, import_yup18.array)().of(
    (0, import_yup18.object)({
      question_id: (0, import_yup18.number)().required("You must pick a question."),
      response: (0, import_yup18.string)().min(3, "Answers must be at least 3 characters.").max(17, "Answers must be at most 17 characters.").required("You must provide an answer to each security question.")
    }).required()
  ).length(3, "You must answer all 3 security questions.").required()
});

// src/records.schema.ts
var import_yup19 = require("yup");
var recordBaseSchema = (0, import_yup19.object)().shape({
  name: (0, import_yup19.string)().max(100, "Record name must be 100 characters or less."),
  target: (0, import_yup19.string)(),
  priority: (0, import_yup19.number)().min(0, "Priority must be between 0 and 255.").max(255, "Priority must be between 0 and 255."),
  weight: (0, import_yup19.number)(),
  port: (0, import_yup19.number)(),
  service: (0, import_yup19.string)().nullable(true),
  protocol: (0, import_yup19.string)().nullable(true),
  ttl_sec: (0, import_yup19.number)(),
  tag: (0, import_yup19.string)()
});
var validRecordTypes = [
  "A",
  "AAAA",
  "NS",
  "MX",
  "CNAME",
  "TXT",
  "SRV",
  "PTR",
  "CAA"
];
var createRecordSchema = recordBaseSchema.shape({
  type: (0, import_yup19.mixed)().required("Type is required.").oneOf(validRecordTypes)
});
var updateRecordSchema = recordBaseSchema.shape({});

// src/stackscripts.schema.ts
var import_yup20 = require("yup");
var stackScriptSchema = (0, import_yup20.object)({
  script: (0, import_yup20.string)().required("Script is required."),
  label: (0, import_yup20.string)().required("Label is required.").min(3, "Label must be between 3 and 128 characters.").max(128, "Label must be between 3 and 128 characters."),
  images: (0, import_yup20.array)().of((0, import_yup20.string)()).required("An image is required."),
  description: (0, import_yup20.string)(),
  is_public: (0, import_yup20.boolean)(),
  rev_note: (0, import_yup20.string)()
});
var updateStackScriptSchema = (0, import_yup20.object)({
  script: (0, import_yup20.string)(),
  label: (0, import_yup20.string)().min(3, "Label must be between 3 and 128 characters.").max(128, "Label must be between 3 and 128 characters."),
  images: (0, import_yup20.array)().of((0, import_yup20.string)()).min(1, "An image is required."),
  description: (0, import_yup20.string)(),
  is_public: (0, import_yup20.boolean)(),
  rev_note: (0, import_yup20.string)()
});

// src/support.schema.ts
var import_yup21 = require("yup");
var createSupportTicketSchema = (0, import_yup21.object)({
  summary: (0, import_yup21.string)().required("Summary is required.").min(1, "Summary must be between 1 and 64 characters.").max(64, "Summary must be between 1 and 64 characters.").trim(),
  description: (0, import_yup21.string)().required("Description is required.").min(1, "Description must be between 1 and 64,000 characters.").max(64e3, "Description must be between 1 and 64,000 characters.").trim(),
  domain_id: (0, import_yup21.number)(),
  linode_id: (0, import_yup21.number)(),
  longviewclient_id: (0, import_yup21.number)(),
  nodebalancer_id: (0, import_yup21.number)(),
  volume_id: (0, import_yup21.number)()
});
var createReplySchema = (0, import_yup21.object)({
  description: (0, import_yup21.string)().required("Description is required.").min(1, "Description must be between 1 and 65,535 characters.").max(65535, "Description must be between 1 and 65,535 characters.").trim()
});

// src/transfers.schema.ts
var import_yup22 = require("yup");
var CreateTransferSchema = (0, import_yup22.object)({
  entities: (0, import_yup22.object)({
    linodes: (0, import_yup22.array)().of((0, import_yup22.number)())
  })
});

// src/twofactor.schema.ts
var import_yup23 = require("yup");
var enableTwoFactorSchema = (0, import_yup23.object)({
  tfa_code: (0, import_yup23.string)().required("Please enter a token.")
});

// src/volumes.schema.ts
var import_yup24 = require("yup");

// src/constants.ts
var MAX_VOLUME_SIZE = 10240;

// src/volumes.schema.ts
var createSizeValidation = (minSize = 10) => (0, import_yup24.number)().integer().typeError(`Size must be a number`).min(minSize, `Size must be between ${minSize} and ${MAX_VOLUME_SIZE}.`).max(
  MAX_VOLUME_SIZE,
  `Size must be between ${minSize} and ${MAX_VOLUME_SIZE}.`
).required(`A size is required.`);
var CreateVolumeSchema = (0, import_yup24.object)({
  region: (0, import_yup24.string)().when("linode_id", {
    is: (id) => id === void 0 || id === "",
    then: (0, import_yup24.string)().required("Must provide a region or a Linode ID.")
  }),
  linode_id: (0, import_yup24.number)().nullable(),
  size: createSizeValidation(10),
  label: (0, import_yup24.string)().required("Label is required.").ensure().trim().min(1, "Label must be between 1 and 32 characters.").max(32, "Label must be 32 characters or less."),
  config_id: (0, import_yup24.number)().nullable().typeError("Config ID must be a number."),
  tags: (0, import_yup24.array)().of((0, import_yup24.string)())
});
var CloneVolumeSchema = (0, import_yup24.object)({
  label: (0, import_yup24.string)().required()
});
var ResizeVolumeSchema = (minSize = 10) => (0, import_yup24.object)({
  size: createSizeValidation(minSize)
});
var UpdateVolumeSchema = (0, import_yup24.object)({
  label: (0, import_yup24.string)().required()
});
var AttachVolumeSchema = (0, import_yup24.object)({
  linode_id: (0, import_yup24.number)().required(),
  config_id: (0, import_yup24.number)().required()
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AttachVolumeSchema,
  AutoscaleNodePoolSchema,
  CUSTOM_PORTS_ERROR_MESSAGE,
  CertificateEntrySchema,
  CloneVolumeSchema,
  ConfigurationSchema,
  CreateBasicLoadbalancerSchema,
  CreateBucketSchema,
  CreateCertificateSchema,
  CreateConfigurationSchema,
  CreateFirewallDeviceSchema,
  CreateFirewallSchema,
  CreateLinodeConfigSchema,
  CreateLinodeDiskFromImageSchema,
  CreateLinodeDiskSchema,
  CreateLinodeSchema,
  CreateLoadBalancerRuleSchema,
  CreateLoadBalancerSchema,
  CreateRouteSchema,
  CreateServiceTargetSchema,
  CreateSnapshotSchema,
  CreateTransferSchema,
  CreateUserSchema,
  CreateVolumeSchema,
  CreditCardSchema,
  EndpointSchema,
  FirewallDeviceSchema,
  FirewallRuleSchema,
  FirewallRuleTypeSchema,
  HTTPRuleSchema,
  IPAllocationSchema,
  IP_ERROR_MESSAGE,
  LinodeInterfaceSchema,
  LinodeInterfacesSchema,
  NodeBalancerSchema,
  PaymentMethodSchema,
  PaymentSchema,
  PromoCodeSchema,
  RebuildLinodeFromStackScriptSchema,
  RebuildLinodeSchema,
  ResizeLinodeDiskSchema,
  ResizeVolumeSchema,
  SecurityQuestionsSchema,
  SendCodeToPhoneNumberSchema,
  TCPRuleSchema,
  UpdateAccountSettingsSchema,
  UpdateBucketAccessSchema,
  UpdateCertificateSchema,
  UpdateConfigInterfaceOrderSchema,
  UpdateConfigInterfaceSchema,
  UpdateConfigurationSchema,
  UpdateFirewallSchema,
  UpdateGrantSchema,
  UpdateLinodeConfigSchema,
  UpdateLinodeDiskSchema,
  UpdateLinodePasswordSchema,
  UpdateLinodeSchema,
  UpdateNodeBalancerConfigSchema,
  UpdateNodeBalancerSchema,
  UpdateRouteSchema,
  UpdateServiceTargetSchema,
  UpdateUserSchema,
  UpdateVolumeSchema,
  UploadCertificateSchema,
  VerifyPhoneNumberCodeSchema,
  allocateIPSchema,
  assignAddressesSchema,
  baseImageSchema,
  clusterLabelSchema,
  createContactSchema,
  createCredentialSchema,
  createDatabaseSchema,
  createDomainSchema,
  createImageSchema,
  createKubeClusterSchema,
  createNodeBalancerConfigSchema,
  createOAuthClientSchema,
  createObjectStorageKeysSchema,
  createPersonalAccessTokenSchema,
  createPlacementGroupSchema,
  createRecordSchema,
  createReplySchema,
  createSSHKeySchema,
  createServiceMonitorSchema,
  createSubnetSchema,
  createSupportTicketSchema,
  createVPCSchema,
  credentialLabel,
  credentialPassword,
  credentialUsername,
  determineIPType,
  enableTwoFactorSchema,
  importZoneSchema,
  ipAddress,
  isCustomPortsValid,
  longviewClientCreate,
  modifySubnetSchema,
  nodeBalancerConfigNodeSchema,
  nodePoolSchema,
  shareAddressesSchema,
  sshSettingSchema,
  stackScriptSchema,
  updateAccountSchema,
  updateCredentialSchema,
  updateDatabaseSchema,
  updateDomainSchema,
  updateIPSchema,
  updateImageSchema,
  updateManagedLinodeSchema,
  updateOAuthClientSchema,
  updateObjectStorageKeysSchema,
  updatePasswordSchema,
  updatePlacementGroupSchema,
  updateProfileSchema,
  updateRecordSchema,
  updateSSHKeySchema,
  updateStackScriptSchema,
  updateVPCSchema,
  uploadImageSchema,
  validateIP,
  vpcsValidateIP
});
