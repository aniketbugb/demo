// src/account.schema.ts
import { array, boolean, mixed, number, object, string } from "yup";
var updateAccountSchema = object({
  email: string().max(128, "Email must be 128 characters or less."),
  address_1: string().max(64, "Address must be 64 characters or less."),
  city: string().max(24, "City must be 24 characters or less."),
  company: string().max(128, "Company must be 128 characters or less."),
  country: string().min(2, "Country code must be two letters.").max(2, "Country code must be two letters."),
  first_name: string().max(50, "First name must be 50 characters or less."),
  last_name: string().max(50, "Last name must be 50 characters or less."),
  address_2: string().max(64, "Address must be 64 characters or less."),
  phone: string().max(32, "Phone number must be 32 characters or less."),
  state: string().max(24, "State must be 24 characters or less."),
  tax_id: string().max(100, "Tax ID must be 100 characters or less."),
  zip: string().max(16, "Zip code must be 16 characters or less.")
});
var createOAuthClientSchema = object({
  label: string().required("Label is required.").min(1, "Label must be between 1 and 512 characters.").max(512, "Label must be between 1 and 512 characters."),
  redirect_uri: string().required("Redirect URI is required.")
});
var updateOAuthClientSchema = object({
  label: string().min(1, "Label must be between 1 and 512 characters.").max(512, "Label must be between 1 and 512 characters."),
  redirect_uri: string()
});
var PaymentSchema = object({
  usd: string().required("USD payment amount is required.")
});
var CreditCardSchema = object({
  card_number: string().required("Credit card number is required.").min(13, "Credit card number must be between 13 and 23 characters.").max(23, "Credit card number must be between 13 and 23 characters."),
  expiry_year: number().test(
    "length",
    "Expiration year must be 2 or 4 digits.",
    (value) => [2, 4].includes(String(value).length)
  ).required("Expiration year is required.").typeError("Expiration year must be a number.").min((/* @__PURE__ */ new Date()).getFullYear(), "Expiration year must not be in the past.").max((/* @__PURE__ */ new Date()).getFullYear() + 20, "Expiry too far in the future."),
  expiry_month: number().required("Expiration month is required.").typeError("Expiration month must be a number.").min(1, "Expiration month must be a number from 1 to 12.").max(12, "Expiration month must be a number from 1 to 12."),
  cvv: string().required("Security code is required.").min(3, "Security code must be between 3 and 4 characters.").max(4, "Security code must be between 3 and 4 characters.")
});
var PaymentMethodSchema = object({
  type: mixed().oneOf(
    ["credit_card", "payment_method_nonce"],
    "Type must be credit_card or payment_method_nonce."
  ),
  data: object().when("type", {
    is: "credit_card",
    then: CreditCardSchema,
    otherwise: object({
      nonce: string().required("Payment nonce is required.")
    })
  }),
  is_default: boolean().required(
    "You must indicate if this should be your default method of payment."
  )
});
var CreateUserSchema = object({
  username: string().required("Username is required.").min(3, "Username must be between 3 and 32 characters.").max(32, "Username must be between 3 and 32 characters."),
  email: string().required("Email address is required.").email("Must be a valid email address."),
  restricted: boolean().required(
    "You must indicate if this user should have restricted access."
  )
});
var UpdateUserSchema = object({
  username: string().min(3, "Username must be between 3 and 32 characters.").max(32, "Username must be between 3 and 32 characters."),
  email: string().email("Must be a valid email address."),
  restricted: boolean()
});
var GrantSchema = object({
  id: number().required("ID is required."),
  permissions: mixed().oneOf(
    [null, "read_only", "read_write"],
    "Permissions must be null, read_only, or read_write."
  )
});
var UpdateGrantSchema = object({
  global: object(),
  linode: array().of(GrantSchema),
  domain: array().of(GrantSchema),
  nodebalancer: array().of(GrantSchema),
  image: array().of(GrantSchema),
  longview: array().of(GrantSchema),
  stackscript: array().of(GrantSchema),
  volume: array().of(GrantSchema)
});
var UpdateAccountSettingsSchema = object({
  network_helper: boolean(),
  backups_enabled: boolean(),
  managed: boolean()
});
var PromoCodeSchema = object({
  promo_code: string().required("Promo code is required.").min(1, "Promo code must be between 1 and 32 characters.").max(32, "Promo code must be between 1 and 32 characters.")
});

// src/buckets.schema.ts
import { boolean as boolean2, object as object2, string as string2 } from "yup";
var CreateBucketSchema = object2().shape(
  {
    label: string2().required("Label is required.").matches(/^\S*$/, "Label must not contain spaces.").ensure().min(3, "Label must be between 3 and 63 characters.").max(63, "Label must be between 3 and 63 characters."),
    cluster: string2().when("region", {
      is: (region) => !region || region.length === 0,
      then: string2().required("Cluster is required.")
    }),
    region: string2().when("cluster", {
      is: (cluster) => !cluster || cluster.length === 0,
      then: string2().required("Region is required.")
    })
  },
  [["cluster", "region"]]
);
var UploadCertificateSchema = object2({
  certificate: string2().required("Certificate is required."),
  private_key: string2().required("Private key is required.")
});
var UpdateBucketAccessSchema = object2({
  acl: string2().oneOf([
    "private",
    "public-read",
    "authenticated-read",
    "public-read-write"
  ]).notRequired(),
  cors_enabled: boolean2().notRequired()
});

// src/databases.schema.ts
import { number as number2 } from "yup";
import { array as array2, object as object3, string as string3 } from "yup";
var LABEL_MESSAGE = "Label must be between 3 and 32 characters";
var createDatabaseSchema = object3({
  label: string3().required("Label is required").min(3, LABEL_MESSAGE).max(32, LABEL_MESSAGE),
  engine: string3().required("Database Engine is required"),
  region: string3().required("Region is required"),
  type: string3().required("Type is required"),
  cluster_size: number2().oneOf([1, 3], "Nodes are required").required("Nodes are required"),
  replication_type: string3().when("engine", {
    is: (engine) => Boolean(engine.match(/mysql|postgres/g)),
    then: string3().when("engine", {
      is: (engine) => Boolean(engine.match(/mysql/)),
      then: string3().oneOf(["none", "semi_synch", "asynch"])
    }).when("engine", {
      is: (engine) => Boolean(engine.match(/postgres/)),
      then: string3().oneOf(["none", "synch", "asynch"])
    }).required("Replication Type is required"),
    otherwise: string3().notRequired().nullable(true)
  }),
  replication_commit_type: string3().when("engine", {
    is: (engine) => Boolean(engine.match(/postgres/)),
    then: string3().oneOf(["off", "on", "local", "remote_write", "remote_apply"]).required(),
    otherwise: string3().notRequired().nullable(true)
  }),
  storage_engine: string3().when("engine", {
    is: (engine) => Boolean(engine.match(/mongodb/)),
    then: string3().oneOf(["wiredtiger", "mmapv1"]).notRequired(),
    otherwise: string3().notRequired().nullable(true)
  }),
  compression_type: string3().when("engine", {
    is: (engine) => Boolean(engine.match(/mongodb/)),
    then: string3().oneOf(["none", "snappy", "zlib"]).notRequired(),
    otherwise: string3().notRequired().nullable(true)
  })
});
var updateDatabaseSchema = object3({
  label: string3().notRequired().min(3, LABEL_MESSAGE).max(32, LABEL_MESSAGE),
  allow_list: array2().of(string3()).notRequired(),
  updates: object3().notRequired().shape({
    frequency: string3().oneOf(["weekly", "monthly"]),
    duration: number2(),
    hour_of_day: number2(),
    day_of_week: number2(),
    week_of_month: number2().nullable(true)
  }).nullable(true),
  type: string3().notRequired()
});

// src/domains.schema.ts
import { array as array3, mixed as mixed2, number as number3, object as object4, string as string4 } from "yup";
var importZoneSchema = object4({
  domain: string4().required("Domain is required."),
  remote_nameserver: string4().required("Remote nameserver is required.")
});
var domainSchemaBase = object4().shape({
  domain: string4().matches(
    /([a-zA-Z0-9-_]+\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|XN--[a-zA-Z0-9]+)/,
    "Domain is not valid."
  ),
  status: mixed2().oneOf(["disabled", "active", "edit_mode", "has_errors"]),
  tags: array3(),
  description: string4().min(1, "Description must be between 1 and 253 characters.").max(253, "Description must be between 1 and 253 characters."),
  retry_sec: number3(),
  master_ips: array3().of(string4()),
  axfr_ips: array3().of(string4()).typeError("Must be a comma-separated list of IP addresses."),
  expire_sec: number3(),
  refresh_sec: number3(),
  ttl_sec: number3()
});
var createDomainSchema = domainSchemaBase.shape({
  domain: string4().required("Domain is required.").matches(
    /([a-zA-Z0-9-_]+\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|XN--[a-zA-Z0-9]+)/,
    "Domain is not valid."
  ),
  tags: array3().of(string4()),
  type: mixed2().required().oneOf(["master", "slave"]),
  soa_email: string4().when("type", {
    is: "master",
    then: string4().required("SOA Email is required."),
    otherwise: string4()
  }).email("SOA Email is not valid.").trim(),
  master_ips: array3().of(string4()).when("type", {
    is: "slave",
    then: array3().of(string4()).compact().ensure().required("At least one primary IP address is required.").min(1, "At least one primary IP address is required."),
    otherwise: array3().of(string4())
  })
});
var updateDomainSchema = domainSchemaBase.shape({
  domainId: number3(),
  soa_email: string4().email("SOA Email is not valid."),
  axfr_ips: array3().of(string4()),
  tags: array3().of(string4())
});

// src/firewalls.schema.ts
import ipaddr from "ipaddr.js";
import { array as array4, mixed as mixed3, number as number4, object as object5, string as string5 } from "yup";
var IP_ERROR_MESSAGE = "Must be a valid IPv4 or IPv6 address or range.";
var validateIP = (ipAddress2) => {
  if (!ipAddress2) {
    return false;
  }
  const [, mask] = ipAddress2.split("/");
  try {
    if (mask) {
      ipaddr.parseCIDR(ipAddress2);
    } else {
      ipaddr.parse(ipAddress2);
    }
  } catch (err) {
    if (ipAddress2 !== "") {
      return false;
    }
  }
  return true;
};
var CreateFirewallDeviceSchema = object5({
  linodes: array4().of(number4()),
  nodebalancers: array4().of(number4())
});
var ipAddress = string5().test({
  name: "validateIP",
  message: IP_ERROR_MESSAGE,
  test: validateIP
});
var CUSTOM_PORTS_ERROR_MESSAGE = "";
var validatePort = (port) => {
  CUSTOM_PORTS_ERROR_MESSAGE = "Ports must be an integer, range of integers, or a comma-separated list of integers.";
  if (!port) {
    CUSTOM_PORTS_ERROR_MESSAGE = "Must be 1-65535";
    return false;
  }
  const convertedPort = parseInt(port, 10);
  if (!(1 <= convertedPort && convertedPort <= 65535)) {
    CUSTOM_PORTS_ERROR_MESSAGE = "Must be 1-65535";
    return false;
  }
  if (port.startsWith("0")) {
    CUSTOM_PORTS_ERROR_MESSAGE = "Port must not have leading zeroes";
    return false;
  }
  if (String(convertedPort) !== port) {
    return false;
  }
  return true;
};
var isCustomPortsValid = (ports) => {
  const portList = (ports == null ? void 0 : ports.split(",")) || [];
  let portLimitCount = 0;
  for (const port of portList) {
    const cleanedPort = port.trim();
    if (cleanedPort.includes("-")) {
      const portRange = cleanedPort.split("-");
      if (!validatePort(portRange[0]) || !validatePort(portRange[1])) {
        return false;
      }
      if (portRange.length !== 2) {
        CUSTOM_PORTS_ERROR_MESSAGE = "Ranges must have 2 values";
        return false;
      }
      if (parseInt(portRange[0], 10) >= parseInt(portRange[1], 10)) {
        CUSTOM_PORTS_ERROR_MESSAGE = "Range must start with a smaller number and end with a larger number";
        return false;
      }
      portLimitCount += 2;
    } else {
      if (!validatePort(cleanedPort)) {
        return false;
      }
      portLimitCount++;
    }
  }
  if (portLimitCount > 15) {
    CUSTOM_PORTS_ERROR_MESSAGE = "Number of ports or port range endpoints exceeded. Max allowed is 15";
    return false;
  }
  return true;
};
var validateFirewallPorts = string5().test({
  name: "firewall-ports",
  message: CUSTOM_PORTS_ERROR_MESSAGE,
  test: (value) => {
    if (!value) {
      return false;
    }
    try {
      isCustomPortsValid(value);
    } catch (err) {
      return false;
    }
    return true;
  }
});
var validFirewallRuleProtocol = ["ALL", "TCP", "UDP", "ICMP", "IPENCAP"];
var FirewallRuleTypeSchema = object5().shape({
  action: mixed3().oneOf(["ACCEPT", "DROP"]).required("Action is required"),
  protocol: mixed3().oneOf(validFirewallRuleProtocol).required("Protocol is required."),
  ports: string5().when("protocol", {
    is: (val) => val !== "ICMP" && val !== "IPENCAP",
    then: validateFirewallPorts,
    // Workaround to get the test to fail if ports is defined when protocol === ICMP or IPENCAP
    otherwise: string5().test({
      name: "protocol",
      message: "Ports are not allowed for ICMP and IPENCAP protocols.",
      test: (value) => typeof value === "undefined"
    })
  }),
  addresses: object5().shape({
    ipv4: array4().of(ipAddress).nullable(true),
    ipv6: array4().of(ipAddress).nullable(true)
  }).strict(true).nullable(true)
});
var FirewallRuleSchema = object5().shape({
  inbound: array4(FirewallRuleTypeSchema).nullable(true),
  outbound: array4(FirewallRuleTypeSchema).nullable(true),
  inbound_policy: mixed3().oneOf(["ACCEPT", "DROP"]).required("Inbound policy is required."),
  outbound_policy: mixed3().oneOf(["ACCEPT", "DROP"]).required("Outbound policy is required.")
});
var CreateFirewallSchema = object5().shape({
  label: string5().required("Label is required.").min(3, "Label must be between 3 and 32 characters.").max(32, "Label must be between 3 and 32 characters."),
  // Label validation on the back end is more complicated, we only do basic checks here.
  tags: array4().of(string5()),
  rules: FirewallRuleSchema
});
var UpdateFirewallSchema = object5().shape({
  label: string5(),
  tags: array4().of(string5()),
  status: string5().oneOf(["enabled", "disabled"])
  // 'deleted' is also a status but it's not settable
});
var FirewallDeviceSchema = object5({
  type: string5().oneOf(["linode", "nodebalancer"]).required("Device type is required."),
  id: number4().required("ID is required.")
});

// src/images.schema.ts
import { boolean as boolean3, number as number5, object as object6, string as string6 } from "yup";
var labelSchema = string6().max(50, "Length must be 50 characters or less.").matches(
  /^[a-zA-Z0-9,.?\-_\s']+$/,
  "Image labels cannot contain special characters."
);
var baseImageSchema = object6().shape({
  label: labelSchema.notRequired(),
  description: string6().notRequired().min(1).max(65e3),
  cloud_init: boolean3().notRequired()
});
var createImageSchema = baseImageSchema.shape({
  disk_id: number5().typeError("Disk is required.").required("Disk is required.")
});
var uploadImageSchema = baseImageSchema.shape({
  label: labelSchema.required("Label is required."),
  region: string6().required("Region is required.")
});
var updateImageSchema = object6().shape({
  label: string6().notRequired().max(50, "Length must be 50 characters or less.").matches(
    /^[a-zA-Z0-9,.?\-_\s']+$/,
    "Image labels cannot contain special characters."
  ),
  description: string6().notRequired().max(65e3, "Length must be 65000 characters or less.")
});

// src/kubernetes.schema.ts
import { array as array5, number as number6, object as object7, string as string7, boolean as boolean4 } from "yup";
var nodePoolSchema = object7().shape({
  type: string7(),
  count: number6()
});
var AutoscaleNodePoolSchema = object7({
  enabled: boolean4(),
  min: number6().when("enabled", {
    is: true,
    then: number6().required().test(
      "min",
      "Minimum must be between 1 and 99 nodes and cannot be greater than Maximum.",
      function(min) {
        if (!min) {
          return false;
        }
        if (min < 1 || min > 99) {
          return false;
        }
        if (min > this.parent["max"]) {
          return false;
        }
        return true;
      }
    )
  }),
  max: number6().when("enabled", {
    is: true,
    then: number6().required().min(1, "Maximum must be between 1 and 100 nodes.").max(100, "Maximum must be between 1 and 100 nodes.")
  })
});
var clusterLabelSchema = string7().required("Label is required.").matches(
  /^[a-zA-Z0-9-]+$/,
  "Cluster labels cannot contain special characters, spaces, or underscores."
).min(3, "Length must be between 3 and 32 characters.").max(32, "Length must be between 3 and 32 characters.");
var createKubeClusterSchema = object7().shape({
  label: clusterLabelSchema,
  region: string7().required("Region is required."),
  k8s_version: string7().required("Kubernetes version is required."),
  node_pools: array5().of(nodePoolSchema).min(1, "Please add at least one node pool.")
});

// src/linodes.schema.ts
import { array as array7, boolean as boolean5, lazy as lazy2, mixed as mixed4, number as number7, object as object9, string as string9 } from "yup";
import ipaddr3 from "ipaddr.js";

// src/vpcs.schema.ts
import ipaddr2 from "ipaddr.js";
import { array as array6, lazy, object as object8, string as string8 } from "yup";
var LABEL_MESSAGE2 = "Label must be between 1 and 64 characters.";
var LABEL_REQUIRED = "Label is required";
var LABEL_REQUIREMENTS = "Must include only ASCII letters, numbers, and dashes";
var labelTestDetails = {
  testName: "no two dashes in a row",
  testMessage: "Must not contain two dashes in a row"
};
var IP_EITHER_BOTH_NOT_NEITHER = "A subnet must have either IPv4 or IPv6, or both, but not neither.";
var determineIPType = (ip) => {
  try {
    let addr;
    const [, mask] = ip.split("/");
    if (mask) {
      const parsed = ipaddr2.parseCIDR(ip);
      addr = parsed[0];
    } else {
      addr = ipaddr2.parse(ip);
    }
    return addr.kind();
  } catch (e) {
    return void 0;
  }
};
var vpcsValidateIP = ({
  value,
  shouldHaveIPMask,
  mustBeIPMask
}) => {
  if (!value) {
    return false;
  }
  const [, mask] = value.trim().split("/");
  if (mustBeIPMask) {
    const valueIsMaskOnly = value === `/${mask}`;
    return !mask ? false : ipaddr2.IPv6.subnetMaskFromPrefixLength(Number(mask)) !== null && valueIsMaskOnly && Number(mask) >= 64 && Number(mask) <= 125;
  }
  try {
    const type = determineIPType(value);
    const isIPv4 = type === "ipv4";
    const isIPv6 = type === "ipv6";
    if (!isIPv4 && !isIPv6) {
      return false;
    }
    if (isIPv4) {
      if (shouldHaveIPMask) {
        ipaddr2.IPv4.parseCIDR(value);
      } else {
        ipaddr2.IPv4.isValid(value);
        ipaddr2.IPv4.parse(value);
      }
    }
    if (isIPv6) {
      if (shouldHaveIPMask) {
        ipaddr2.IPv6.parseCIDR(value);
      } else {
        ipaddr2.IPv6.isValid(value);
        ipaddr2.IPv6.parse(value);
      }
    }
    return true;
  } catch (err) {
    return false;
  }
};
var labelValidation = string8().test(
  labelTestDetails.testName,
  labelTestDetails.testMessage,
  (value) => !(value == null ? void 0 : value.includes("--"))
).min(1, LABEL_MESSAGE2).max(64, LABEL_MESSAGE2).matches(/[a-zA-Z0-9-]+/, LABEL_REQUIREMENTS);
var updateVPCSchema = object8({
  label: labelValidation.notRequired(),
  description: string8().notRequired()
});
var createSubnetSchema = object8().shape(
  {
    label: labelValidation.required(LABEL_REQUIRED),
    ipv4: string8().when("ipv6", {
      is: void 0,
      then: string8().required(IP_EITHER_BOTH_NOT_NEITHER).test({
        name: "IPv4 CIDR format",
        message: "The IPv4 range must be in CIDR format",
        test: (value) => vpcsValidateIP({
          value,
          shouldHaveIPMask: true,
          mustBeIPMask: false
        })
      }),
      otherwise: lazy((value) => {
        switch (typeof value) {
          case "undefined":
            return string8().notRequired().nullable();
          case "string":
            return string8().notRequired().test({
              name: "IPv4 CIDR format",
              message: "The IPv4 range must be in CIDR format",
              test: (value2) => vpcsValidateIP({
                value: value2,
                shouldHaveIPMask: true,
                mustBeIPMask: false
              })
            });
          default:
            return string8().notRequired().nullable();
        }
      })
    }),
    ipv6: string8().when("ipv4", {
      is: void 0,
      then: string8().required(IP_EITHER_BOTH_NOT_NEITHER).test({
        name: "IPv6 prefix length",
        message: "Must be the prefix length (64-125) of the IP, e.g. /64",
        test: (value) => vpcsValidateIP({
          value,
          shouldHaveIPMask: true,
          mustBeIPMask: true
        })
      }),
      otherwise: lazy((value) => {
        switch (typeof value) {
          case "undefined":
            return string8().notRequired().nullable();
          case "string":
            return string8().notRequired().test({
              name: "IPv6 prefix length",
              message: "Must be the prefix length (64-125) of the IP, e.g. /64",
              test: (value2) => vpcsValidateIP({
                value: value2,
                shouldHaveIPMask: true,
                mustBeIPMask: true
              })
            });
          default:
            return string8().notRequired().nullable();
        }
      })
    })
  },
  [
    ["ipv6", "ipv4"],
    ["ipv4", "ipv6"]
  ]
);
var createVPCSchema = object8({
  label: labelValidation.required(LABEL_REQUIRED),
  description: string8(),
  region: string8().required("Region is required"),
  subnets: array6().of(createSubnetSchema)
});
var modifySubnetSchema = object8({
  label: labelValidation.required(LABEL_REQUIRED)
});

// src/linodes.schema.ts
var validateIP2 = (ipAddress2) => {
  if (!ipAddress2) {
    return true;
  }
  try {
    ipaddr3.parseCIDR(ipAddress2);
  } catch (err) {
    return false;
  }
  return true;
};
var test_vpcsValidateIP = (value) => {
  if (value === void 0 || value === null) {
    return true;
  }
  return vpcsValidateIP({
    value,
    shouldHaveIPMask: false,
    mustBeIPMask: false
  });
};
var testnameDisallowedBasedOnPurpose = (allowedPurpose) => `Disallowed for non-${allowedPurpose} interfaces`;
var testmessageDisallowedBasedOnPurpose = (allowedPurpose, field) => `${field} is not allowed for interfaces that do not have a purpose set to ${allowedPurpose}.`;
var LINODE_LABEL_CHAR_REQUIREMENT = "Label must contain between 3 and 64 characters.";
var stackscript_data = array7().of(object9()).nullable(true);
var IPv4 = string9().notRequired().nullable().test({
  name: "validateIPv4",
  message: "Must be a valid IPv4 address, e.g. 192.168.2.0",
  test: (value) => test_vpcsValidateIP(value)
});
var IPv6 = string9().notRequired().nullable().test({
  name: "validateIPv6",
  message: "Must be a valid IPv6 address, e.g. 2600:3c00::f03c:92ff:feeb:98f9.",
  test: (value) => test_vpcsValidateIP(value)
});
var ipv4ConfigInterface = object9().when("purpose", {
  is: "vpc",
  then: object9({
    vpc: IPv4,
    nat_1_1: lazy2(
      (value) => value === "any" ? string9().notRequired().nullable() : IPv4
    )
  }),
  otherwise: object9().nullable().test({
    name: testnameDisallowedBasedOnPurpose("VPC"),
    message: testmessageDisallowedBasedOnPurpose("vpc", "ipv4.vpc"),
    /*
      Workaround to get test to fail if field is populated when it should not be based
      on purpose (inspired by similar approach in firewalls.schema.ts for ports field).
      Similarly-structured logic (return typeof xyz === 'undefined') throughout this
      file serves the same purpose.
    */
    test: (value) => {
      if (value == null ? void 0 : value.vpc) {
        return typeof value.vpc === "undefined";
      }
      return true;
    }
  }).test({
    name: testnameDisallowedBasedOnPurpose("VPC"),
    message: testmessageDisallowedBasedOnPurpose("vpc", "ipv4.nat_1_1"),
    test: (value) => {
      if (value == null ? void 0 : value.nat_1_1) {
        return typeof value.nat_1_1 === "undefined";
      }
      return true;
    }
  })
});
var ipv6ConfigInterface = object9().when("purpose", {
  is: "vpc",
  then: object9({
    vpc: IPv6
  }),
  otherwise: object9().nullable().test({
    name: testnameDisallowedBasedOnPurpose("VPC"),
    message: testmessageDisallowedBasedOnPurpose("vpc", "ipv6.vpc"),
    test: (value) => {
      if (value == null ? void 0 : value.vpc) {
        return typeof value.vpc === "undefined";
      }
      return true;
    }
  })
});
var LinodeInterfaceSchema = object9().shape({
  purpose: mixed4().oneOf(
    ["public", "vlan", "vpc"],
    "Purpose must be public, vlan, or vpc."
  ),
  label: string9().when("purpose", {
    is: "vlan",
    then: string9().required("VLAN label is required.").min(1, "VLAN label must be between 1 and 64 characters.").max(64, "VLAN label must be between 1 and 64 characters.").matches(
      /[a-zA-Z0-9-]+/,
      "Must include only ASCII letters, numbers, and dashes"
    ),
    otherwise: string9().when("label", {
      is: null,
      then: string9().nullable(),
      otherwise: string9().test({
        name: testnameDisallowedBasedOnPurpose("VLAN"),
        message: testmessageDisallowedBasedOnPurpose("vlan", "label"),
        test: (value) => typeof value === "undefined" || value === ""
      })
    })
  }),
  ipam_address: string9().when("purpose", {
    is: "vlan",
    then: string9().notRequired().nullable().test({
      name: "validateIPAM",
      message: "Must be a valid IPv4 range, e.g. 192.0.2.0/24.",
      test: validateIP2
    }),
    otherwise: string9().when("ipam_address", {
      is: null,
      then: string9().nullable(),
      otherwise: string9().test({
        name: testnameDisallowedBasedOnPurpose("VLAN"),
        message: testmessageDisallowedBasedOnPurpose("vlan", "ipam_address"),
        test: (value) => typeof value === "undefined" || value === ""
      })
    })
  }),
  primary: boolean5().notRequired(),
  subnet_id: number7().when("purpose", {
    is: "vpc",
    then: number7().transform((value) => isNaN(value) ? void 0 : value).required("Subnet is required."),
    otherwise: number7().test({
      name: testnameDisallowedBasedOnPurpose("VPC"),
      message: testmessageDisallowedBasedOnPurpose("vpc", "subnet_id"),
      test: (value) => typeof value === "undefined"
    })
  }),
  vpc_id: number7().when("purpose", {
    is: "vpc",
    then: number7().required("VPC is required."),
    otherwise: number7().test({
      name: testnameDisallowedBasedOnPurpose("VPC"),
      message: testmessageDisallowedBasedOnPurpose("vpc", "vpc_id"),
      test: (value) => typeof value === "undefined"
    })
  }),
  ipv4: ipv4ConfigInterface,
  ipv6: ipv6ConfigInterface,
  ip_ranges: array7().of(string9()).when("purpose", {
    is: "vpc",
    then: array7().of(
      string9().test(
        "valid-ip-range",
        "Must be a valid IPv4 range, e.g. 192.0.2.0/24.",
        validateIP2
      )
    ).notRequired(),
    otherwise: array7().test({
      name: testnameDisallowedBasedOnPurpose("VPC"),
      message: testmessageDisallowedBasedOnPurpose("vpc", "ip_ranges"),
      test: (value) => typeof value === "undefined"
    })
  })
});
var LinodeInterfacesSchema = array7().of(LinodeInterfaceSchema).test(
  "unique-public-interface",
  "Only one public interface per config is allowed.",
  (list) => {
    if (!list) {
      return true;
    }
    return list.filter((thisSlot) => thisSlot.purpose === "public").length <= 1;
  }
);
var UpdateConfigInterfaceOrderSchema = object9({
  ids: array7().of(number7()).required("The list of interface IDs is required.")
});
var UpdateConfigInterfaceSchema = object9({
  primary: boolean5().notRequired(),
  ipv4: object9().notRequired().shape({
    vpc: IPv4,
    nat_1_1: lazy2(
      (value) => value === "any" ? string9().notRequired().nullable() : IPv4
    )
  }),
  ipv6: object9().notRequired().nullable().shape({
    vpc: IPv6
  }),
  ip_ranges: array7().of(string9().test(validateIP2)).max(1).notRequired()
});
var ResizeLinodeDiskSchema = object9({
  size: number7().required("Size is required.").min(1)
});
var UpdateLinodePasswordSchema = object9({
  password: string9().required("Password is required.")
  // .concat(rootPasswordValidation)
});
var MetadataSchema = object9({
  user_data: string9().notRequired().nullable(true)
});
var PlacementGroupPayloadSchema = object9({
  id: number7().notRequired().nullable(true)
});
var DiskEncryptionSchema = object9({
  disk_encryption: string9().oneOf(["enabled", "disabled"]).nullable().notRequired()
});
var CreateLinodeSchema = object9({
  type: string9().ensure().required("Plan is required."),
  region: string9().ensure().required("Region is required."),
  stackscript_id: number7().nullable().notRequired(),
  backup_id: number7().nullable().notRequired(),
  swap_size: number7().notRequired(),
  image: string9().when("stackscript_id", {
    is: (value) => value !== void 0,
    then: string9().ensure().required("Image is required."),
    otherwise: string9().nullable().notRequired()
  }),
  authorized_keys: array7().of(string9()).notRequired(),
  backups_enabled: boolean5().notRequired(),
  stackscript_data,
  booted: boolean5().notRequired(),
  label: string9().transform((v) => v === "" ? void 0 : v).notRequired().min(3, LINODE_LABEL_CHAR_REQUIREMENT).max(64, LINODE_LABEL_CHAR_REQUIREMENT),
  tags: array7().of(string9()).notRequired(),
  private_ip: boolean5().notRequired(),
  authorized_users: array7().of(string9()).notRequired(),
  root_pass: string9().when("image", {
    is: (value) => Boolean(value),
    then: string9().required(
      "You must provide a root password when deploying from an image."
    ),
    // .concat(rootPasswordValidation),
    otherwise: string9().notRequired()
  }),
  interfaces: LinodeInterfacesSchema,
  metadata: MetadataSchema,
  firewall_id: number7().nullable().notRequired(),
  placement_group: PlacementGroupPayloadSchema,
  disk_encryption: DiskEncryptionSchema
});
var alerts = object9({
  cpu: number7().typeError("CPU Usage must be a number").min(0, "Must be between 0 and 4800").max(4800, "Must be between 0 and 4800"),
  network_in: number7(),
  network_out: number7(),
  transfer_quota: number7(),
  io: number7()
}).notRequired();
var schedule = object9({
  day: mixed4().oneOf(
    [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    "Invalid day value."
  ),
  window: mixed4().oneOf(
    [
      "W0",
      "W2",
      "W4",
      "W6",
      "W8",
      "W10",
      "W12",
      "W14",
      "W16",
      "W18",
      "W20",
      "W22",
      "W24"
    ],
    "Invalid schedule value."
  )
});
var backups = object9({
  schedule,
  enabled: boolean5()
});
var UpdateLinodeSchema = object9({
  label: string9().transform((v) => v === "" ? void 0 : v).notRequired().min(3, LINODE_LABEL_CHAR_REQUIREMENT).max(64, LINODE_LABEL_CHAR_REQUIREMENT),
  tags: array7().of(string9()).notRequired(),
  watchdog_enabled: boolean5().notRequired(),
  alerts,
  backups
});
var SSHKeySchema = object9({
  id: number7(),
  label: string9(),
  ssh_key: string9(),
  created: string9()
});
var RebuildLinodeSchema = object9().shape({
  image: string9().required("An image is required."),
  root_pass: string9().required("Password is required."),
  authorized_keys: array7().of(SSHKeySchema),
  authorized_users: array7().of(string9()),
  stackscript_id: number7().notRequired(),
  stackscript_data,
  booted: boolean5().notRequired(),
  metadata: MetadataSchema,
  disk_encryption: DiskEncryptionSchema
});
var RebuildLinodeFromStackScriptSchema = RebuildLinodeSchema.shape({
  stackscript_id: number7().required("A StackScript is required.")
});
var IPAllocationSchema = object9({
  type: string9().required("IP address type (IPv4) is required.").oneOf(["ipv4"], "Only IPv4 addresses can be allocated."),
  public: boolean5().required("Must specify public or private IP address.")
});
var CreateSnapshotSchema = object9({
  label: string9().required("A snapshot label is required.").min(1, "Label must be between 1 and 255 characters.").max(255, "Label must be between 1 and 255 characters.")
});
var device = object9({
  disk_id: number7().nullable(true),
  volume_id: number7().nullable(true)
}).nullable(true);
var devices = object9({
  sda: device,
  sdb: device,
  sdc: device,
  sdd: device,
  sde: device,
  sdf: device,
  sdg: device,
  sdh: device
});
var helpers = object9({
  updatedb_disabled: boolean5(),
  distro: boolean5(),
  modules_dep: boolean5(),
  network: boolean5(),
  devtmpfs_automount: boolean5()
});
var CreateLinodeConfigSchema = object9({
  label: string9().required("Label is required.").min(1, "Label must be between 1 and 48 characters.").max(48, "Label must be between 1 and 48 characters."),
  devices: devices.required("A list of devices is required."),
  kernel: string9(),
  comments: string9(),
  memory_limit: number7(),
  run_level: mixed4().oneOf(["default", "single", "binbash"]),
  virt_mode: mixed4().oneOf(["paravirt", "fullvirt"]),
  helpers,
  root_device: string9(),
  interfaces: LinodeInterfacesSchema
});
var UpdateLinodeConfigSchema = object9({
  label: string9().min(1, "Label must be between 1 and 48 characters.").max(48, "Label must be between 1 and 48 characters."),
  devices,
  kernel: string9(),
  comments: string9(),
  memory_limit: number7(),
  run_level: mixed4().oneOf(["default", "single", "binbash"]),
  virt_mode: mixed4().oneOf(["paravirt", "fullvirt"]),
  helpers,
  root_device: string9(),
  interfaces: LinodeInterfacesSchema
});
var CreateLinodeDiskSchema = object9({
  size: number7().required("Disk size is required."),
  label: string9().required("A disk label is required.").min(1, "Label must be between 1 and 48 characters.").max(48, "Label must be between 1 and 48 characters."),
  filesystem: mixed4().oneOf(["raw", "swap", "ext3", "ext4", "initrd"]),
  read_only: boolean5(),
  image: string9(),
  authorized_keys: array7().of(string9()),
  authorized_users: array7().of(string9()),
  root_pass: string9().when("image", {
    is: (value) => Boolean(value),
    then: string9().required(
      "You must provide a root password when deploying from an image."
    ),
    // .concat(rootPasswordValidation),
    otherwise: string9().notRequired()
  }),
  stackscript_id: number7(),
  stackscript_data
});
var UpdateLinodeDiskSchema = object9({
  label: string9().notRequired().min(1, "Label must be between 1 and 48 characters.").max(48, "Label must be between 1 and 48 characters."),
  filesystem: mixed4().notRequired().oneOf(["raw", "swap", "ext3", "ext4", "initrd"])
});
var CreateLinodeDiskFromImageSchema = CreateLinodeDiskSchema.clone().shape(
  {
    image: string9().required("An image is required.")
  }
);

// src/loadbalancers.schema.ts
import { number as number8, object as object10, string as string10, array as array8 } from "yup";
var LABEL_REQUIRED2 = "Label is required.";
var matchFieldOptions = [
  "always_match",
  "path_prefix",
  "path_regex",
  "query",
  "header",
  "method"
];
var CreateCertificateSchema = object10({
  certificate: string10().required("Certificate is required."),
  key: string10().when("type", {
    is: "downstream",
    then: string10().required("Private Key is required.")
  }),
  label: string10().required(LABEL_REQUIRED2),
  type: string10().oneOf(["downstream", "ca"]).required("Type is required.")
});
var UpdateCertificateSchema = object10().shape(
  {
    certificate: string10(),
    key: string10().when(["type", "certificate"], {
      is: (type, certificate) => type === "downstream" && certificate,
      then: string10().required("Private Key is required")
    }),
    label: string10().min(1, "Label must not be empty."),
    type: string10().oneOf(["downstream", "ca"])
  },
  [["certificate", "key"]]
);
var CertificateEntrySchema = object10({
  id: number8().typeError("Certificate ID must be a number.").required("Certificate ID is required.").min(0, "Certificate ID is required."),
  hostname: string10().required("A Host Header is required.")
});
var EndpointSchema = object10({
  ip: string10().required("IP is required."),
  host: string10().nullable(),
  port: number8().required("Port is required.").min(1, "Port must be greater than 0.").max(65535, "Port must be less than or equal to 65535."),
  rate_capacity: number8().required("Rate Capacity is required.")
});
var HealthCheckSchema = object10({
  protocol: string10().oneOf(["http", "tcp"]),
  interval: number8().typeError("Interval must be a number.").min(1, "Interval must be greater than zero."),
  timeout: number8().typeError("Timeout must be a number.").min(1, "Timeout must be greater than zero."),
  unhealthy_threshold: number8().typeError("Unhealthy Threshold must be a number.").min(1, "Unhealthy Threshold must be greater than zero."),
  healthy_threshold: number8().typeError("Healthy Threshold must be a number.").min(1, "Healthy Threshold must be greater than zero."),
  path: string10().nullable(),
  host: string10().when("protocol", {
    is: "tcp",
    then: (o) => o.nullable(),
    otherwise: (o) => o.required("Health Check host is required.")
  })
});
var CreateServiceTargetSchema = object10({
  label: string10().required(LABEL_REQUIRED2),
  protocol: string10().oneOf(["tcp", "http", "https"]).required(),
  endpoints: array8(EndpointSchema).required(),
  certificate_id: string10().nullable(),
  load_balancing_policy: string10().required().oneOf(["round_robin", "least_request", "ring_hash", "random", "maglev"]),
  healthcheck: HealthCheckSchema
});
var UpdateServiceTargetSchema = object10({
  label: string10().min(1, "Label must not be empty."),
  protocol: string10().oneOf(["tcp", "http", "https"]),
  endpoints: array8(EndpointSchema),
  certificate_id: number8().nullable(),
  load_balancing_policy: string10().oneOf([
    "round_robin",
    "least_request",
    "ring_hash",
    "random",
    "maglev"
  ]),
  healthcheck: HealthCheckSchema
});
var CreateRouteSchema = object10({
  label: string10().required(LABEL_REQUIRED2),
  protocol: string10().oneOf(["http", "tcp"])
});
var RouteServiceTargetSchema = object10({
  id: number8().min(0, "Service Target ID is required.").required("Service Target ID is required."),
  percentage: number8().min(0, "Percent must be greater than or equal to 0.").max(100, "Percent must be less than or equal to 100.").typeError("Percent must be a number.").required("Percent is required.")
});
var MatchConditionSchema = object10({
  hostname: string10().nullable(),
  match_field: string10().oneOf(matchFieldOptions).required("Match field is required."),
  match_value: string10().required("Match value is required."),
  session_stickiness_cookie: string10().nullable(),
  session_stickiness_ttl: number8().min(0, "TTL must be greater than or equal to 0.").typeError("TTL must be a number.").nullable()
});
var TCPRuleSchema = object10({
  service_targets: array8(RouteServiceTargetSchema).test(
    "sum-of-percentage",
    "The sum of the percentages must be 100",
    (serviceTargets) => {
      if (!serviceTargets || serviceTargets.length === 0) {
        return true;
      }
      const sum = serviceTargets.reduce((acc, serviceTarget) => {
        var _a;
        return acc + ((_a = serviceTarget == null ? void 0 : serviceTarget.percentage) != null ? _a : 0);
      }, 0);
      return sum === 100;
    }
  ).min(1, "Rules must have at least 1 Service Target.").required()
});
var HTTPRuleSchema = TCPRuleSchema.concat(
  object10({
    match_condition: MatchConditionSchema
  })
);
var UpdateRouteSchema = object10({
  label: string10().min(1, "Label must not be empty."),
  protocol: string10().oneOf(["tcp", "http"]),
  rules: array8().when("protocol", {
    is: "tcp",
    then: (o) => o.of(TCPRuleSchema),
    otherwise: (o) => o.of(HTTPRuleSchema)
  })
});
var UpdateConfigurationSchema = object10({
  label: string10().min(1, "Label must not be empty."),
  port: number8().min(1, "Port must be greater than 0.").max(65535, "Port must be less than or equal to 65535.").typeError("Port must be a number."),
  protocol: string10().oneOf(["tcp", "http", "https"]),
  certificates: array8().when("protocol", {
    is: "https",
    then: (o) => o.of(CertificateEntrySchema).min(1, "Certificates must not be empty for HTTPS configurations.").required(),
    otherwise: (o) => o.max(0).notRequired()
  }),
  route_ids: array8().of(number8())
});
var CreateConfigurationSchema = object10({
  label: string10().min(1, "Label must not be empty.").required("Label is required."),
  port: number8().min(1, "Port must be greater than 0.").max(65535, "Port must be less than or equal to 65535.").typeError("Port must be a number.").required("Port is required."),
  protocol: string10().oneOf(["tcp", "http", "https"]).required(),
  certificates: array8().when("protocol", {
    is: "https",
    then: (o) => o.of(CertificateEntrySchema).min(1, "Certificates must not be empty for HTTPS configurations.").required(),
    otherwise: (o) => o.max(0).notRequired()
  }),
  route_ids: array8().of(number8())
});
var CreateLoadBalancerEndpointSchema = object10({
  ip: string10().required(),
  host: string10(),
  port: number8().integer().required(),
  rate_capacity: number8().integer().required()
});
var CreateLoadBalancerServiceTargetSchema = object10({
  percentage: number8().integer().required(),
  label: string10().required(),
  endpoints: array8().of(CreateLoadBalancerEndpointSchema).required(),
  certificate_id: number8().integer().nullable(),
  load_balancing_policy: string10().oneOf(["round_robin", "least_request", "ring_hash", "random", "maglev"]).required(),
  healthcheck: HealthCheckSchema.required()
});
var CreateLoadBalancerRuleSchema = object10({
  match_condition: object10().shape({
    hostname: string10().nullable(),
    match_field: string10().oneOf(matchFieldOptions).required(),
    match_value: string10().required(),
    session_stickiness_cookie: string10().nullable(),
    session_stickiness_ttl: number8().integer().nullable()
  }),
  service_targets: array8().of(CreateLoadBalancerServiceTargetSchema).required()
});
var ConfigurationSchema = object10({
  label: string10().required(LABEL_REQUIRED2),
  port: number8().min(1, "Port must be greater than 0.").max(65535, "Port must be less than or equal to 65535.").typeError("Port must be a number.").required("Port is required."),
  protocol: string10().oneOf(["tcp", "http", "https"]).required(),
  certificates: array8().when("protocol", {
    is: (val) => val === "https",
    then: (o) => o.of(CertificateEntrySchema).required(),
    otherwise: (o) => o.notRequired()
  }),
  routes: array8().when("protocol", {
    is: "tcp",
    then: (o) => o.of(
      object10({
        label: string10().required(LABEL_REQUIRED2),
        protocol: string10().oneOf(["tcp"]).required(),
        rules: array8().of(CreateLoadBalancerRuleSchema).required()
      })
    ),
    otherwise: (o) => o.of(
      object10({
        label: string10().required(),
        protocol: string10().oneOf(["http"]).required(),
        rules: array8().of(CreateLoadBalancerRuleSchema).required()
      })
    )
  })
});
var CreateLoadBalancerSchema = object10({
  label: string10().min(1, "Label must not be empty.").required(LABEL_REQUIRED2),
  // tags: array().of(string()), // TODO: ACLB - Should confirm on this with API team. Assuming this will be out of scope for Beta.
  regions: array8().of(string10()).required(),
  configurations: array8().of(ConfigurationSchema)
});
var CreateBasicLoadbalancerSchema = object10({
  label: string10().min(1, "Label must not be empty.").required("Label is required")
});

// src/longview.schema.ts
import { object as object11, string as string11 } from "yup";
var longviewClientCreate = object11().shape({
  label: string11().min(3, "Label must be between 3 and 32 characters.").max(32, "Label must be between 3 and 32 characters.")
});

// src/managed.schema.ts
import { array as array9, boolean as boolean6, mixed as mixed5, number as number9, object as object12, string as string12 } from "yup";
var createServiceMonitorSchema = object12().shape({
  label: string12().required("Label is required.").min(3, "Label must be between 3 and 64 characters.").max(64, "Label must be between 3 and 64 characters."),
  service_type: mixed5().required("Monitor type is required.").oneOf(["url", "tcp"]),
  address: string12().required("URL is required."),
  timeout: number9().required("Timeout is required."),
  credentials: array9().of(number9()).notRequired(),
  notes: string12().notRequired(),
  consultation_group: string12().notRequired(),
  body: string12().notRequired().max(100, "Body must be 100 characters or less.")
});
var sshSettingSchema = object12().shape({
  access: boolean6(),
  user: string12().max(32, "User must be 32 characters or less."),
  ip: string12(),
  port: number9().min(1, "Port must be between 1 and 65535.").max(65535, "Port must be between 1 and 65535.")
});
var updateManagedLinodeSchema = object12({
  ssh: sshSettingSchema
});
var credentialLabel = string12().min(2, "Label must be between 2 and 75 characters.").max(75, "Label must be between 2 and 75 characters.");
var credentialPassword = string12().notRequired().max(5e3, "Password must be 5000 characters or less.");
var credentialUsername = string12().notRequired().max(5e3, "Username must be 5000 characters or less.");
var createCredentialSchema = object12().shape({
  label: credentialLabel.required("Label is required."),
  username: credentialUsername,
  password: credentialPassword
});
var updateCredentialSchema = object12().shape({
  label: credentialLabel.required("Label is required.")
});
var updatePasswordSchema = object12().shape({
  username: credentialUsername,
  password: credentialPassword.required("Password is required.")
});
var createContactSchema = object12().shape({
  name: string12().required("Name is required.").min(2, "Name must be between 2 and 64 characters.").max(64, "Name must be between 2 and 64 characters."),
  email: string12().required("E-mail is required.").min(6, "E-mail must be between 6 and 100 characters").max(100, "E-mail must be between 6 and 100 characters").email("Invalid e-mail address"),
  phone: object12().shape({
    primary: string12().nullable(true).notRequired(),
    secondary: string12().nullable(true).notRequired()
  }).notRequired(),
  group: string12().notRequired().nullable(true).min(2, "Group must be between 2 and 50 characters.").max(50, "Group must be between 2 and 50 characters.")
});

// src/networking.schema.ts
import { array as array10, boolean as boolean7, number as number10, object as object13, string as string13 } from "yup";
var updateIPSchema = object13().shape({
  rdns: string13().notRequired().nullable(true)
});
var allocateIPSchema = object13().shape({
  type: string13().required().matches(
    /^ipv4$/,
    "Only IPv4 address may be allocated through this endpoint."
  ),
  public: boolean7().required(),
  linode_id: number10().required()
});
var assignAddressesSchema = object13().shape({
  region: string13().required(),
  assignments: array10().of(object13()).required()
});
var shareAddressesSchema = object13().shape({
  linode_id: number10().required(),
  ips: array10().of(string13())
});

// src/nodebalancers.schema.ts
import { array as array11, boolean as boolean8, mixed as mixed6, number as number11, object as object14, string as string14 } from "yup";
var PORT_WARNING = "Port must be between 1 and 65535.";
var LABEL_WARNING = "Label must be between 3 and 32 characters.";
var nodeBalancerConfigNodeSchema = object14({
  label: string14().matches(
    /^[a-zA-Z0-9.\-_]+$/,
    "Label may only contain letters, numbers, periods, dashes, and underscores."
  ).min(3, "Label should be between 3 and 32 characters.").max(32, "Label should be between 3 and 32 characters.").required("Label is required."),
  address: string14().typeError("IP address is required.").required("IP address is required.").matches(
    /^192\.168\.\d{1,3}\.\d{1,3}$/,
    "Must be a valid private IPv4 address."
  ),
  port: number11().typeError("Port must be a number.").required("Port is required.").min(1, PORT_WARNING).max(65535, PORT_WARNING),
  weight: number11().typeError("Weight must be a number.").min(1, `Weight must be between 1 and 255.`).max(255, `Weight must be between 1 and 255.`),
  mode: mixed6().oneOf(["accept", "reject", "backup", "drain"])
});
var createNodeBalancerConfigSchema = object14({
  algorithm: mixed6().oneOf(["roundrobin", "leastconn", "source"]),
  check_attempts: number11(),
  check_body: string14().when("check", {
    is: "http_body",
    then: string14().required("An HTTP body regex is required.")
  }),
  check_interval: number11().typeError("Check interval must be a number."),
  check_passive: boolean8(),
  check_path: string14().matches(/\/.*/).when("check", {
    is: "http",
    then: string14().required("An HTTP path is required.")
  }).when("check", {
    is: "http_body",
    then: string14().required("An HTTP path is required.")
  }),
  proxy_protocol: string14().oneOf(["none", "v1", "v2"]),
  check_timeout: number11().typeError("Timeout must be a number.").integer(),
  check: mixed6().oneOf(["none", "connection", "http", "http_body"]),
  cipher_suite: mixed6().oneOf(["recommended", "legacy"]),
  port: number11().integer().required("Port is required").min(1, PORT_WARNING).max(65535, PORT_WARNING),
  protocol: mixed6().oneOf(["http", "https", "tcp"]),
  ssl_key: string14().when("protocol", {
    is: "https",
    then: string14().required("SSL key is required when using HTTPS.")
  }),
  ssl_cert: string14().when("protocol", {
    is: "https",
    then: string14().required("SSL certificate is required when using HTTPS.")
  }),
  stickiness: mixed6().oneOf(["none", "table", "http_cookie"]),
  nodes: array11().of(nodeBalancerConfigNodeSchema).required().min(1, "You must provide at least one back end node.")
});
var UpdateNodeBalancerConfigSchema = object14({
  algorithm: mixed6().oneOf(["roundrobin", "leastconn", "source"]),
  check_attempts: number11(),
  check_body: string14().when("check", {
    is: "http_body",
    then: string14().required("An HTTP body regex is required.")
  }),
  check_interval: number11().typeError("Check interval must be a number."),
  check_passive: boolean8(),
  check_path: string14().matches(/\/.*/).when("check", {
    is: "http",
    then: string14().required("An HTTP path is required.")
  }).when("check", {
    is: "http_body",
    then: string14().required("An HTTP path is required.")
  }),
  proxy_protocol: string14().oneOf(["none", "v1", "v2"]),
  check_timeout: number11().typeError("Timeout must be a number.").integer(),
  check: mixed6().oneOf(["none", "connection", "http", "http_body"]),
  cipher_suite: mixed6().oneOf(["recommended", "legacy"]),
  port: number11().typeError("Port must be a number.").integer().min(1, PORT_WARNING).max(65535, PORT_WARNING),
  protocol: mixed6().oneOf(["http", "https", "tcp"]),
  ssl_key: string14().when("protocol", {
    is: "https",
    then: string14().required()
  }),
  ssl_cert: string14().when("protocol", {
    is: "https",
    then: string14().required()
  }),
  stickiness: mixed6().oneOf(["none", "table", "http_cookie"]),
  nodes: array11().of(nodeBalancerConfigNodeSchema)
});
var NodeBalancerSchema = object14({
  label: string14().required("Label is required.").min(3, LABEL_WARNING).max(32, LABEL_WARNING).matches(
    /^[a-zA-Z0-9-_]+$/,
    "Label can't contain special characters or spaces."
  ),
  client_conn_throttle: number11().typeError("Must be a number."),
  region: string14().required("Region is required."),
  configs: array11().of(createNodeBalancerConfigSchema).test("unique", "Port must be unique.", function(value) {
    if (!value) {
      return true;
    }
    const ports = [];
    const configs = value.reduce(
      (prev, value2, idx) => {
        if (!value2.port) {
          return prev;
        }
        if (!ports.includes(value2.port)) {
          ports.push(value2.port);
          return prev;
        }
        return [...prev, idx];
      },
      []
    );
    if (configs.length === 0) {
      return true;
    }
    const configStrings = configs.map(
      (config) => `configs[${config}].port`
    );
    throw this.createError({
      path: configStrings.join("|"),
      message: "Port must be unique."
    });
  })
});
var UpdateNodeBalancerSchema = object14({
  label: string14().min(3, LABEL_WARNING).max(32, LABEL_WARNING).matches(
    /^[a-zA-Z0-9-_]+$/,
    "Label can't contain special characters or spaces."
  ),
  client_conn_throttle: number11().typeError("Must be a number."),
  region: string14()
});

// src/objectStorageKeys.schema.ts
import { object as object15, string as string15, array as array12 } from "yup";
var labelErrorMessage = "Label must be between 3 and 50 characters.";
var createObjectStorageKeysSchema = object15({
  label: string15().required("Label is required.").min(3, labelErrorMessage).max(50, labelErrorMessage).trim(),
  regions: array12().of(string15()).min(1, "Select at least one region to continue").notRequired()
});
var updateObjectStorageKeysSchema = object15({
  label: string15().notRequired().min(3, labelErrorMessage).max(50, labelErrorMessage).trim(),
  regions: array12().of(string15()).min(
    1,
    `Select at least one region. To remove all regions, use 'Revoke' in the actions menu and remove the access key.`
  ).notRequired()
});

// src/placement-groups.schema.ts
import { boolean as boolean9, object as object16, string as string16 } from "yup";
var labelValidation2 = string16().required("Label is required.").min(3, "Label must be between 3 and 32 characters.").max(32, "Label must be between 3 and 32 characters.");
var createPlacementGroupSchema = object16({
  label: labelValidation2,
  affinity_type: string16().required("Affinity type is required."),
  region: string16().required("Region is required."),
  is_strict: boolean9().required("Is strict is required.")
});
var updatePlacementGroupSchema = object16({
  label: labelValidation2
});

// src/profile.schema.ts
import { array as array13, boolean as boolean10, number as number12, object as object17, string as string17 } from "yup";
import { isPossiblePhoneNumber } from "libphonenumber-js";
var createPersonalAccessTokenSchema = object17({
  scopes: string17(),
  expiry: string17(),
  label: string17().min(1, "Label must be between 1 and 100 characters.").max(100, "Label must be between 1 and 100 characters.")
});
var createSSHKeySchema = object17({
  label: string17().required("Label is required.").min(1, "Label must be between 1 and 64 characters.").max(64, "Label must be between 1 and 64 characters.").trim(),
  ssh_key: string17()
});
var updateSSHKeySchema = object17({
  label: string17().required("Label is required.").min(1, "Label must be between 1 and 64 characters.").max(64, "Label must be between 1 and 64 characters.").trim()
});
var updateProfileSchema = object17({
  email: string17().email(),
  timezone: string17(),
  email_notifications: boolean10(),
  authorized_keys: array13().of(string17()),
  restricted: boolean10(),
  two_factor_auth: boolean10(),
  lish_auth_method: string17().oneOf(["password_keys", "keys_only", "disabled"]),
  authentication_type: string17().oneOf(["password", "github"])
});
var SendCodeToPhoneNumberSchema = object17({
  iso_code: string17().required(),
  phone_number: string17().test(
    "is-phone-number",
    "Not a valid phone number",
    (phone_number, context) => {
      const { iso_code } = context.parent;
      if (!phone_number) {
        return false;
      }
      return isPossiblePhoneNumber(phone_number, iso_code);
    }
  )
});
var VerifyPhoneNumberCodeSchema = object17({
  otp_code: string17().required("Verification Code is required.").test(
    "digits only",
    "The verification code must only contain digits.",
    (value) => {
      if (!value) {
        return true;
      }
      return /^\d+$/.test(value);
    }
  )
});
var SecurityQuestionsSchema = object17({
  security_questions: array13().of(
    object17({
      question_id: number12().required("You must pick a question."),
      response: string17().min(3, "Answers must be at least 3 characters.").max(17, "Answers must be at most 17 characters.").required("You must provide an answer to each security question.")
    }).required()
  ).length(3, "You must answer all 3 security questions.").required()
});

// src/records.schema.ts
import { mixed as mixed7, number as number13, object as object18, string as string18 } from "yup";
var recordBaseSchema = object18().shape({
  name: string18().max(100, "Record name must be 100 characters or less."),
  target: string18(),
  priority: number13().min(0, "Priority must be between 0 and 255.").max(255, "Priority must be between 0 and 255."),
  weight: number13(),
  port: number13(),
  service: string18().nullable(true),
  protocol: string18().nullable(true),
  ttl_sec: number13(),
  tag: string18()
});
var validRecordTypes = [
  "A",
  "AAAA",
  "NS",
  "MX",
  "CNAME",
  "TXT",
  "SRV",
  "PTR",
  "CAA"
];
var createRecordSchema = recordBaseSchema.shape({
  type: mixed7().required("Type is required.").oneOf(validRecordTypes)
});
var updateRecordSchema = recordBaseSchema.shape({});

// src/stackscripts.schema.ts
import { array as array14, boolean as boolean11, object as object19, string as string19 } from "yup";
var stackScriptSchema = object19({
  script: string19().required("Script is required."),
  label: string19().required("Label is required.").min(3, "Label must be between 3 and 128 characters.").max(128, "Label must be between 3 and 128 characters."),
  images: array14().of(string19()).required("An image is required."),
  description: string19(),
  is_public: boolean11(),
  rev_note: string19()
});
var updateStackScriptSchema = object19({
  script: string19(),
  label: string19().min(3, "Label must be between 3 and 128 characters.").max(128, "Label must be between 3 and 128 characters."),
  images: array14().of(string19()).min(1, "An image is required."),
  description: string19(),
  is_public: boolean11(),
  rev_note: string19()
});

// src/support.schema.ts
import { number as number14, object as object20, string as string20 } from "yup";
var createSupportTicketSchema = object20({
  summary: string20().required("Summary is required.").min(1, "Summary must be between 1 and 64 characters.").max(64, "Summary must be between 1 and 64 characters.").trim(),
  description: string20().required("Description is required.").min(1, "Description must be between 1 and 64,000 characters.").max(64e3, "Description must be between 1 and 64,000 characters.").trim(),
  domain_id: number14(),
  linode_id: number14(),
  longviewclient_id: number14(),
  nodebalancer_id: number14(),
  volume_id: number14()
});
var createReplySchema = object20({
  description: string20().required("Description is required.").min(1, "Description must be between 1 and 65,535 characters.").max(65535, "Description must be between 1 and 65,535 characters.").trim()
});

// src/transfers.schema.ts
import { array as array15, number as number15, object as object21 } from "yup";
var CreateTransferSchema = object21({
  entities: object21({
    linodes: array15().of(number15())
  })
});

// src/twofactor.schema.ts
import { object as object22, string as string21 } from "yup";
var enableTwoFactorSchema = object22({
  tfa_code: string21().required("Please enter a token.")
});

// src/volumes.schema.ts
import { array as array16, number as number16, object as object23, string as string22 } from "yup";

// src/constants.ts
var MAX_VOLUME_SIZE = 10240;

// src/volumes.schema.ts
var createSizeValidation = (minSize = 10) => number16().integer().typeError(`Size must be a number`).min(minSize, `Size must be between ${minSize} and ${MAX_VOLUME_SIZE}.`).max(
  MAX_VOLUME_SIZE,
  `Size must be between ${minSize} and ${MAX_VOLUME_SIZE}.`
).required(`A size is required.`);
var CreateVolumeSchema = object23({
  region: string22().when("linode_id", {
    is: (id) => id === void 0 || id === "",
    then: string22().required("Must provide a region or a Linode ID.")
  }),
  linode_id: number16().nullable(),
  size: createSizeValidation(10),
  label: string22().required("Label is required.").ensure().trim().min(1, "Label must be between 1 and 32 characters.").max(32, "Label must be 32 characters or less."),
  config_id: number16().nullable().typeError("Config ID must be a number."),
  tags: array16().of(string22())
});
var CloneVolumeSchema = object23({
  label: string22().required()
});
var ResizeVolumeSchema = (minSize = 10) => object23({
  size: createSizeValidation(minSize)
});
var UpdateVolumeSchema = object23({
  label: string22().required()
});
var AttachVolumeSchema = object23({
  linode_id: number16().required(),
  config_id: number16().required()
});
export {
  AttachVolumeSchema,
  AutoscaleNodePoolSchema,
  CUSTOM_PORTS_ERROR_MESSAGE,
  CertificateEntrySchema,
  CloneVolumeSchema,
  ConfigurationSchema,
  CreateBasicLoadbalancerSchema,
  CreateBucketSchema,
  CreateCertificateSchema,
  CreateConfigurationSchema,
  CreateFirewallDeviceSchema,
  CreateFirewallSchema,
  CreateLinodeConfigSchema,
  CreateLinodeDiskFromImageSchema,
  CreateLinodeDiskSchema,
  CreateLinodeSchema,
  CreateLoadBalancerRuleSchema,
  CreateLoadBalancerSchema,
  CreateRouteSchema,
  CreateServiceTargetSchema,
  CreateSnapshotSchema,
  CreateTransferSchema,
  CreateUserSchema,
  CreateVolumeSchema,
  CreditCardSchema,
  EndpointSchema,
  FirewallDeviceSchema,
  FirewallRuleSchema,
  FirewallRuleTypeSchema,
  HTTPRuleSchema,
  IPAllocationSchema,
  IP_ERROR_MESSAGE,
  LinodeInterfaceSchema,
  LinodeInterfacesSchema,
  NodeBalancerSchema,
  PaymentMethodSchema,
  PaymentSchema,
  PromoCodeSchema,
  RebuildLinodeFromStackScriptSchema,
  RebuildLinodeSchema,
  ResizeLinodeDiskSchema,
  ResizeVolumeSchema,
  SecurityQuestionsSchema,
  SendCodeToPhoneNumberSchema,
  TCPRuleSchema,
  UpdateAccountSettingsSchema,
  UpdateBucketAccessSchema,
  UpdateCertificateSchema,
  UpdateConfigInterfaceOrderSchema,
  UpdateConfigInterfaceSchema,
  UpdateConfigurationSchema,
  UpdateFirewallSchema,
  UpdateGrantSchema,
  UpdateLinodeConfigSchema,
  UpdateLinodeDiskSchema,
  UpdateLinodePasswordSchema,
  UpdateLinodeSchema,
  UpdateNodeBalancerConfigSchema,
  UpdateNodeBalancerSchema,
  UpdateRouteSchema,
  UpdateServiceTargetSchema,
  UpdateUserSchema,
  UpdateVolumeSchema,
  UploadCertificateSchema,
  VerifyPhoneNumberCodeSchema,
  allocateIPSchema,
  assignAddressesSchema,
  baseImageSchema,
  clusterLabelSchema,
  createContactSchema,
  createCredentialSchema,
  createDatabaseSchema,
  createDomainSchema,
  createImageSchema,
  createKubeClusterSchema,
  createNodeBalancerConfigSchema,
  createOAuthClientSchema,
  createObjectStorageKeysSchema,
  createPersonalAccessTokenSchema,
  createPlacementGroupSchema,
  createRecordSchema,
  createReplySchema,
  createSSHKeySchema,
  createServiceMonitorSchema,
  createSubnetSchema,
  createSupportTicketSchema,
  createVPCSchema,
  credentialLabel,
  credentialPassword,
  credentialUsername,
  determineIPType,
  enableTwoFactorSchema,
  importZoneSchema,
  ipAddress,
  isCustomPortsValid,
  longviewClientCreate,
  modifySubnetSchema,
  nodeBalancerConfigNodeSchema,
  nodePoolSchema,
  shareAddressesSchema,
  sshSettingSchema,
  stackScriptSchema,
  updateAccountSchema,
  updateCredentialSchema,
  updateDatabaseSchema,
  updateDomainSchema,
  updateIPSchema,
  updateImageSchema,
  updateManagedLinodeSchema,
  updateOAuthClientSchema,
  updateObjectStorageKeysSchema,
  updatePasswordSchema,
  updatePlacementGroupSchema,
  updateProfileSchema,
  updateRecordSchema,
  updateSSHKeySchema,
  updateStackScriptSchema,
  updateVPCSchema,
  uploadImageSchema,
  validateIP,
  vpcsValidateIP
};
